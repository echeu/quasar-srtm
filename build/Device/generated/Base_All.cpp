
/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.

    This file was generated by quasar (https://github.com/quasar-team/quasar/)

    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.

 */



#include <Configuration.hxx>

/* Note: need to have full declarations of classes on which we will call
  "delete" operator plus more, and not just base classes */
#include <DRegs.h>

namespace Device
{


// ctr
Base_DRegs::Base_DRegs (
    const Configuration::Regs& config,
    Parent_DRegs* parent
):
    m_parent(parent),
    m_addressSpaceLink(nullptr),
    m_stringAddress("**NB**")
    , m_address( config.address() )   {
}

// dtr
Base_DRegs::~Base_DRegs ()
{
    // part 1 of dtr: remove all legit children (i.e. non-orphaned objects)


}

void Base_DRegs::linkAddressSpace(
    AddressSpace::ASRegs* addressSpaceLink,
    const std::string& stringAddress)
{
    if (m_addressSpaceLink)
        throw std::logic_error("addressSpaceLink can be established only once. Looks like a logic error.");
    m_addressSpaceLink = addressSpaceLink;
    m_stringAddress.assign( stringAddress );
}

AddressSpace::ASRegs* Base_DRegs::getAddressSpaceLink () const
{
    if (m_addressSpaceLink)
        return m_addressSpaceLink;
    else
        throw std::logic_error("m_addressSpaceLink is nullptr! at:"+m_stringAddress);
}

/* For constructing the tree of devices and for browsing children. */


/** Disconnects AddressSpace part from the Device logic, and does the same for all children
    Returns number of unlinked objects including self **/
unsigned int Base_DRegs::unlinkAllChildren ()
{
    unsigned int objectCounter = 1;  // 1 is for self
    m_addressSpaceLink = nullptr;
    return objectCounter;
}

/* find methods for children */






// lists of orphaned objects, per class
std::list<DRegs*> Base_DRegs::s_orphanedObjects;
}