

/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.

    This file was generated by quasar (https://github.com/quasar-team/quasar/)

    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.

 */



#ifndef __Base_DRegs__H__
#define __Base_DRegs__H__

#include <vector>
#include <string>
#include <list>
#include <boost/thread/mutex.hpp> // will go to std soon, see OPCUA-1759

#include <opcua_platformdefs.h>
#include <statuscode.h>
#include <uadatetime.h>

/* forward decl for AddressSpace */
namespace AddressSpace {
class ASRegs;
}

/* forward decl for Configuration */
namespace Configuration {
class Regs;
}

namespace Device
{
class     DRoot;

typedef     DRoot Parent_DRegs;

class DRegs;

/* forward declarations (comes from design.class.has_objects) */


class Base_DRegs
{
public:
    /* Constructor */
    explicit Base_DRegs (
        const Configuration::Regs& config,
        Parent_DRegs* parent
    ) ;

    /* No copy constructors or assignment operators */
    Base_DRegs (const Base_DRegs& other) = delete;
    Base_DRegs& operator=(const Base_DRegs& other) = delete;

    /* dtr */
    virtual ~Base_DRegs ();

    Parent_DRegs* getParent () const {
        return m_parent;
    }



    /* to safely quit */
    unsigned int unlinkAllChildren ();

    void linkAddressSpace (AddressSpace::ASRegs* as, const std::string& stringAddress);
    AddressSpace::ASRegs* getAddressSpaceLink () const;

    /* find methods for children */


    /* getters for values which are keys */
    const OpcUa_UInt32 address() {
        return m_address;
    }

    /* mutex operations */

    /* variable-wise locks */



    /* method-wise locks */

    /* query address-space for full name (mostly for debug purposes) */
    std::string getFullName() const {
        return m_stringAddress;
    }

    static std::list<DRegs*> s_orphanedObjects;
    static void registerOrphanedObject( DRegs* object ) {
        s_orphanedObjects.push_back( object );
    }
    static std::list<DRegs*>& orphanedObjects() {
        return s_orphanedObjects;
    }

private:
    Parent_DRegs* m_parent;
    AddressSpace::ASRegs* m_addressSpaceLink;
    std::string m_stringAddress;

    /* Collections of device logic children objects */


    /* if any of our cachevariables has isKey=true then we shall keep its copy here for find functions  (it is const, either way) */
    const OpcUa_UInt32 m_address;

    /* object-wise lock */

    /* variable-wise locks */



    /* method-wise locks */

};

}

#endif // __Base_DRegs__H__