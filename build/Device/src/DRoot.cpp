

/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.

    This file was generated by quasar (https://github.com/quasar-team/quasar/)

    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.

 */



#include <stdexcept>

#include <DRoot.h>
#include <LogIt.h>

// Need to have full declarations of classes on which we will call "delete" operator
#include <DRegs.h>


namespace Device
{

/* Singleton's instance. */
DRoot* DRoot::m_instance = nullptr;

DRoot::DRoot()
{
    if (m_instance != 0)
        throw std::logic_error("DRoot can be instantiated just once");
    m_instance = this;
}

DRoot::~DRoot()
{
    // part 1 of dtr: remove all legit children (i.e. non-orphaned objects)
    for (auto* obj : regss())
        delete obj;
    m_Regss.clear();


    // part 2 of dtr: remove all orphaned objects
    {
        auto objects = Base_DRegs::orphanedObjects ();
        for (auto* obj : objects)
            delete obj;
        objects.clear();
    }
}

DRoot* DRoot::getInstance()
{
    if (m_instance == 0)
    {
        throw std::logic_error ("DRoot: instance not yet created. ");
    }
    return m_instance;
}

/* For constructing the tree of devices and for browsing children. */
void DRoot::add (DRegs* device)
{
    m_Regss.push_back (device);
}
const std::vector<DRegs* >& DRoot::regss () const
{
    return m_Regss;
}


void DRoot::unlinkAllChildren () const
{
    unsigned int objectCounter = 0;
    // part 1: unlinking all legit children
    for (auto* obj : regss())
        objectCounter += obj->unlinkAllChildren();

    // part 2: unlinking all orphaned children
    {
        auto objects = Base_DRegs::orphanedObjects ();
        for (auto* obj : objects)
            objectCounter += obj->unlinkAllChildren();
    }
    LOG(Log::INF) << "DRoot::unlinkAllChildren(): " << objectCounter << " objects unlinked ";
}

/* find methods for children */


}