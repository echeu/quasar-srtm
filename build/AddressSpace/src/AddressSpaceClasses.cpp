
/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.

    This file was generated by quasar (https://github.com/quasar-team/quasar/)

    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.

 */


#include <string> // for std::to_string
#include <climits>

#include <ArrayTools.h>
#include <Utils.h>
#include <ChangeNotifyingVariable.h>
#include <CalculatedVariablesEngine.h>

#include <SourceVariables.h>

#include <ASRegs.h>
#include <DRegs.h>

namespace AddressSpace
{

static std::string decorateSingleVariableNodeName (const std::string& basicName, bool isSingleVariableNode)
{
    if (isSingleVariableNode)
        return "__single_item_node__" + basicName;
    else
        return basicName;
}


/*ctr*/
ASRegs::ASRegs (
    UaNodeId                            parentNodeId,
    const UaNodeId&                     typeNodeId,
    ASNodeManager*                      nm,
    const Configuration::Regs& config):
    OpcUa::BaseObjectType (
        /*nodeId*/ nm->makeChildNodeId(
            parentNodeId,
            decorateSingleVariableNodeName(config.name(), false).c_str()),
        /*name*/decorateSingleVariableNodeName(config.name(), false).c_str(),
        nm->getNameSpaceIndex(),
        nm),
    m_typeNodeId (typeNodeId),
    m_effectiveParentNodeIdForChildren(this->nodeId())
    ,
    m_userReg (nullptr) // this cache-variable will be created in the ctr body
    ,
    m_writeRegValue (nullptr) // this cache-variable will be created in the ctr body
    ,
    m_deviceLink(nullptr)
{

    UaStatus status;

    status = nm->addNodeAndReferenceThrows( parentNodeId, this, OpcUaId_HasComponent, this->nodeId() );

    createCacheVariables(nm, config);
    initializeArrayCacheVariablesFromConfiguration(nm, config);
    createSourceVariables(nm, config);
    createMethods(nm, config);
    createPropertiesFromConfigEntries(nm, config);

}

void ASRegs::createCacheVariables(
    ASNodeManager* nm,
    const Configuration::Regs& config)
{
    UaStatus status;
    UaVariant helperVariant;
    UaString variableName;
    variableName = fixChildNameWhenSingleNodeClass(
                       "userReg",
                       config.name().c_str());
    m_userReg = new ChangeNotifyingVariable (
        nm->makeChildNodeId(
            m_effectiveParentNodeIdForChildren,
            variableName),
        variableName,
        nm->getNameSpaceIndex(),
        UaVariant(),
        OpcUa_AccessLevels_CurrentRead,
        nm);


    m_userReg->setValueRank( -1 ); // scalar

    helperVariant.clear ();
    m_userReg->setValue(
        /*pSession*/ nullptr,
        UaDataValue(
            helperVariant,
            OpcUa_BadWaitingForInitialData,
            UaDateTime::now(),
            UaDateTime::now()),
        /*check access level*/ OpcUa_False);


    nm->addNodeAndReferenceThrows(
        m_effectiveParentNodeIdForChildren,
        m_userReg,
        OpcUaId_HasComponent,
        m_userReg->nodeId());


    CalculatedVariables::Engine::registerVariableForCalculatedVariables( m_userReg );

    variableName = fixChildNameWhenSingleNodeClass(
                       "writeRegValue",
                       config.name().c_str());
    m_writeRegValue = new ASDelegatingVariable<ASRegs> (
        nm->makeChildNodeId(
            m_effectiveParentNodeIdForChildren,
            variableName),
        variableName,
        nm->getNameSpaceIndex(),
        UaVariant(),
        OpcUa_AccessLevels_CurrentReadOrWrite,
        nm);


    m_writeRegValue->setValueRank( -1 ); // scalar

    helperVariant.setUInt32 ( 0 );
    m_writeRegValue->setValue(
        /*pSession*/ nullptr,
        UaDataValue(
            helperVariant,
            OpcUa_Good,
            UaDateTime::now(),
            UaDateTime::now()),
        /*check access level*/ OpcUa_False);


    nm->addNodeAndReferenceThrows(
        m_effectiveParentNodeIdForChildren,
        m_writeRegValue,
        OpcUaId_HasComponent,
        m_writeRegValue->nodeId());


    CalculatedVariables::Engine::registerVariableForCalculatedVariables( m_writeRegValue );

}

void ASRegs::initializeArrayCacheVariablesFromConfiguration(
    ASNodeManager* nm,
    const Configuration::Regs& config)
{
}

void ASRegs::createSourceVariables(
    ASNodeManager* nm,
    const Configuration::Regs& config)
{
    UaStatus status;
    UaString variableName;
}

void ASRegs::createMethods(
    ASNodeManager* nm,
    const Configuration::Regs& config)
{
    UaStatus status;
    UaString methodName;
}

void ASRegs::createPropertiesFromConfigEntries(
    ASNodeManager* nm,
    const Configuration::Regs& config)
{
    {
        UaVariant defaultValue;
        defaultValue.setUInt32 (
            config.address()                );
        UaPropertyCache* property = new UaPropertyCache(
            "address",
            nm->makeChildNodeId(
                m_effectiveParentNodeIdForChildren,
                "address"),
            defaultValue,
            OpcUa_AccessLevels_CurrentRead,
            "");
        nm->addNodeAndReferenceThrows(
            m_effectiveParentNodeIdForChildren,
            property,
            OpcUaId_HasProperty,
            property->nodeId());
    }
}

ASRegs::~ASRegs ()
{
    if (m_deviceLink)
    {
        LOG(Log::ERR) << "While destructing the class, device logic link is still not null. Sth went wrong with quasar logic...";
    }
}

UaString ASRegs::fixChildNameWhenSingleNodeClass(
    const std::string& nameByDesign,
    const std::string& nameByConfig
) const
{
    return nameByDesign.c_str();
}

/* generate setters and getters -- for scalar cache-variables first */
UaStatus ASRegs::setUserReg( const OpcUa_UInt32 value, OpcUa_StatusCode statusCode, const UaDateTime& srcTime )
{
    UaVariant v;
    v.setUInt32 (value);
    return m_userReg->setValue (/*session*/ nullptr, UaDataValue (v, statusCode, srcTime, UaDateTime::now()), /*check access*/ OpcUa_False );
}

//! the basic getter, it's always there no matter what.
UaStatus ASRegs::getUserReg (OpcUa_UInt32& returnValue) const
{
    UaVariant v (* (m_userReg->value(/*session*/ nullptr).value()));
    return v.toUInt32( returnValue );
}


/* null-setter (possible because nullPolicy=nullAllowed) -- old style -- will be deprecated */
UaStatus ASRegs::setNullUserReg( OpcUa_StatusCode statusCode, const UaDateTime& srcTime)
{
    UaVariant v;
    return m_userReg->setValue (
               /*session*/ nullptr,
               UaDataValue (
                   v,
                   statusCode,
                   srcTime,
                   UaDateTime::now()),
               /*check access*/OpcUa_False );
}

/* null-setter (possible because nullPolicy=nullAllowed) -- new style */
UaStatus ASRegs::setUserReg( QuasarNullDataType null, OpcUa_StatusCode statusCode, const UaDateTime& srcTime )
{
    UaVariant v;
    return m_userReg->setValue (
               /*session*/ nullptr,
               UaDataValue (
                   v,
                   statusCode,
                   srcTime,
                   UaDateTime::now()),
               /*check access*/OpcUa_False );
}
UaStatus ASRegs::setWriteRegValue( const OpcUa_UInt32 value, OpcUa_StatusCode statusCode, const UaDateTime& srcTime )
{
    UaVariant v;
    v.setUInt32 (value);
    return m_writeRegValue->setValue (/*session*/ nullptr, UaDataValue (v, statusCode, srcTime, UaDateTime::now()), /*check access*/ OpcUa_False );
}

//! the basic getter, it's always there no matter what.
UaStatus ASRegs::getWriteRegValue (OpcUa_UInt32& returnValue) const
{
    UaVariant v (* (m_writeRegValue->value(/*session*/ nullptr).value()));
    return v.toUInt32( returnValue );
}


/* null-setter (possible because nullPolicy=nullAllowed) -- old style -- will be deprecated */
UaStatus ASRegs::setNullWriteRegValue( OpcUa_StatusCode statusCode, const UaDateTime& srcTime)
{
    UaVariant v;
    return m_writeRegValue->setValue (
               /*session*/ nullptr,
               UaDataValue (
                   v,
                   statusCode,
                   srcTime,
                   UaDateTime::now()),
               /*check access*/OpcUa_False );
}

/* null-setter (possible because nullPolicy=nullAllowed) -- new style */
UaStatus ASRegs::setWriteRegValue( QuasarNullDataType null, OpcUa_StatusCode statusCode, const UaDateTime& srcTime )
{
    UaVariant v;
    return m_writeRegValue->setValue (
               /*session*/ nullptr,
               UaDataValue (
                   v,
                   statusCode,
                   srcTime,
                   UaDateTime::now()),
               /*check access*/OpcUa_False );
}

/* generate setters and getters -- now for arrays */



/* generate delegates (if requested) */
// @note Piotr: regular to be there only for arrays, for scalars it is not necessary.
UaStatus ASRegs::writeWriteRegValue( Session* pSession, const UaDataValue& dataValue, OpcUa_Boolean checkAccessLevel )
{
    /* ensure that data type passed by OPC UA client matches specification */
    UaVariant v (*dataValue.value()); // TODO : do we really need this copy?
    if (v.type() != OpcUaType_UInt32 )
    {
        if (v.type() != OpcUaType_Null)
            return OpcUa_BadDataEncodingInvalid; // now we know it is neither the intended datatype nor NULL
    }
    return OpcUa_Good;
}


/* generate device logic link */
void ASRegs::linkDevice( Device::DRegs* deviceLink)
{
    if (m_deviceLink) /* This is an error -- device can be linked at most once in the object's lifetime. */
        throw std::logic_error("linkDevice() should be called only once. Quasar logic error?");
    else
        m_deviceLink = deviceLink;
}

void ASRegs::unlinkDevice ()
{
    m_deviceLink = nullptr;
}


}