
/*  © Copyright CERN, 2015. All rights not expressly granted are reserved.
    Authors(from Quasar team): Piotr Nikiel

    This file is part of Quasar.

    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.

    This file was completely generated by Quasar (additional info: using transform designToClassBody.xslt)
    on 2018-11-09T17:06:17.136+01:00
 */


#include <climits>

#include <ArrayTools.h>
#include <Utils.h>

#include <ASBuildInformation.h>


#include <DBuildInformation.h>


namespace AddressSpace
{



/*ctr*/
ASBuildInformation::ASBuildInformation (
    UaNodeId parentNodeId,
    const UaNodeId& typeNodeId,
    ASNodeManager *nm,
	const std::string& host, const std::string& timestamp, const std::string commitID, const std::string& toolkitLibs):
    OpcUa::BaseObjectType (
        /*nodeId*/
        nm->makeChildNodeId(parentNodeId,"BuildInformation"), "BuildInformation", nm->getNameSpaceIndex(), nm),
    m_typeNodeId (typeNodeId)


    ,


    m_BuildHost (new

                 OpcUa::BaseDataVariableType


                 (nm->makeChildNodeId(
                      this->nodeId(),
                      UaString("BuildHost")), UaString("BuildHost"), nm->getNameSpaceIndex(), UaVariant(UaString(host.c_str())),

                  OpcUa_AccessLevels_CurrentRead
                  , nm))
    ,


    m_BuildTimestamp (new

                      OpcUa::BaseDataVariableType


                      (nm->makeChildNodeId(
                           this->nodeId(),
                           UaString("BuildTimestamp")), UaString("BuildTimestamp"), nm->getNameSpaceIndex(), UaVariant(UaString(timestamp.c_str())),

                       OpcUa_AccessLevels_CurrentRead
                       , nm))
    ,


    m_CommitID (new

                OpcUa::BaseDataVariableType


                (nm->makeChildNodeId(
                     this->nodeId(),
                     UaString("CommitID")), UaString("CommitID"), nm->getNameSpaceIndex(), UaVariant(UaString(commitID.c_str())),

                 OpcUa_AccessLevels_CurrentRead
                 , nm))
    ,


    m_ToolkitLibs (new

                   OpcUa::BaseDataVariableType


                   (nm->makeChildNodeId(
                        this->nodeId(),
                        UaString("ToolkitLibs")), UaString("ToolkitLibs"), nm->getNameSpaceIndex(), UaVariant(UaString(toolkitLibs.c_str())),

                    OpcUa_AccessLevels_CurrentRead
                    , nm))
    ,
    m_deviceLink (0)



{

    UaStatus s;
    UaVariant v;


    s = nm->addNodeAndReference( parentNodeId, this, OpcUaId_HasComponent);
    if (!s.isGood())
    {
        LOG(Log::ERR) << "While addNodeAndReference from " << parentNodeId.toString().toUtf8() << " to " << this->nodeId().toString().toUtf8() << " : ";
        ASSERT_GOOD(s);
    }



    m_BuildHost->setDataType(UaNodeId( OpcUaType_String, 0 )); // assumption: BuiltInTypeId matches numeric address of the type in namespace0

    // found scalar signature: can simply load the variant with the scalar
    // fnc:dataTypeToVariantSetter(@dataType)
    v.setString (
        host.c_str()
    );
    m_BuildHost->setValue(/*pSession*/0, UaDataValue(UaVariant( v ), OpcUa_Good, UaDateTime::now(), UaDateTime::now() ), /*check access level*/OpcUa_False);


    s = nm->addNodeAndReference(
            this,
            m_BuildHost, OpcUaId_HasComponent);
    if (!s.isGood())
    {
        LOG(Log::ERR) << "While addNodeAndReference from " << this->nodeId().toString().toUtf8() << " to " << m_BuildHost->nodeId().toString().toUtf8() << " : " << std::endl;
        ASSERT_GOOD(s);
    }



    m_BuildTimestamp->setDataType(UaNodeId( OpcUaType_String, 0 )); // assumption: BuiltInTypeId matches numeric address of the type in namespace0

    // found scalar signature: can simply load the variant with the scalar
    // fnc:dataTypeToVariantSetter(@dataType)
    v.setString (
        timestamp.c_str()
    );
    m_BuildTimestamp->setValue(/*pSession*/0, UaDataValue(UaVariant( v ), OpcUa_Good, UaDateTime::now(), UaDateTime::now() ), /*check access level*/OpcUa_False);


    s = nm->addNodeAndReference(
            this,
            m_BuildTimestamp, OpcUaId_HasComponent);
    if (!s.isGood())
    {
        LOG(Log::ERR) << "While addNodeAndReference from " << this->nodeId().toString().toUtf8() << " to " << m_BuildTimestamp->nodeId().toString().toUtf8() << " : " << std::endl;
        ASSERT_GOOD(s);
    }



    m_CommitID->setDataType(UaNodeId( OpcUaType_String, 0 )); // assumption: BuiltInTypeId matches numeric address of the type in namespace0

    // found scalar signature: can simply load the variant with the scalar
    // fnc:dataTypeToVariantSetter(@dataType)
    v.setString (
        commitID.c_str()
    );
    m_CommitID->setValue(/*pSession*/0, UaDataValue(UaVariant( v ), OpcUa_Good, UaDateTime::now(), UaDateTime::now() ), /*check access level*/OpcUa_False);


    s = nm->addNodeAndReference(
            this,
            m_CommitID, OpcUaId_HasComponent);
    if (!s.isGood())
    {
        LOG(Log::ERR) << "While addNodeAndReference from " << this->nodeId().toString().toUtf8() << " to " << m_CommitID->nodeId().toString().toUtf8() << " : " << std::endl;
        ASSERT_GOOD(s);
    }



    m_ToolkitLibs->setDataType(UaNodeId( OpcUaType_String, 0 )); // assumption: BuiltInTypeId matches numeric address of the type in namespace0

    // found scalar signature: can simply load the variant with the scalar
    // fnc:dataTypeToVariantSetter(@dataType)
    v.setString (
        toolkitLibs.c_str()
    );
    m_ToolkitLibs->setValue(/*pSession*/0, UaDataValue(UaVariant( v ), OpcUa_Good, UaDateTime::now(), UaDateTime::now() ), /*check access level*/OpcUa_False);


    s = nm->addNodeAndReference(
            this,
            m_ToolkitLibs, OpcUaId_HasComponent);
    if (!s.isGood())
    {
        LOG(Log::ERR) << "While addNodeAndReference from " << this->nodeId().toString().toUtf8() << " to " << m_ToolkitLibs->nodeId().toString().toUtf8() << " : " << std::endl;
        ASSERT_GOOD(s);
    }




}





ASBuildInformation::~ASBuildInformation ()
{

    if (m_deviceLink != 0)
    {
        LOG(Log::ERR) << "deviceLink not zero!!";
    }

}




/* generate setters and getters (if requested) */


UaStatus ASBuildInformation::setBuildHost (const UaString & value, OpcUa_StatusCode statusCode,const UaDateTime & srcTime )
{

    UaVariant v;

    v.setString( value );

    return m_BuildHost->setValue (0, UaDataValue (v, statusCode, srcTime, UaDateTime::now()), /*check access*/OpcUa_False  ) ;

}


UaStatus ASBuildInformation::getBuildHost (UaString & r) const
{
    UaVariant v (* (m_BuildHost->value(/*session*/0).value()));

    if (v.type() == OpcUaType_String)
    {
        r = v.toString();
        return OpcUa_Good;
    }
    else
        return OpcUa_Bad;

}

/* short getter (possible because this variable will never be null) */
UaString ASBuildInformation::getBuildHost () const
{
    UaVariant v (* m_BuildHost->value (0).value() );
    UaString v_value;
    v_value = v.toString();
    return v_value;
}


UaStatus ASBuildInformation::setBuildTimestamp (const UaString & value, OpcUa_StatusCode statusCode,const UaDateTime & srcTime )
{

    UaVariant v;

    v.setString( value );

    return m_BuildTimestamp->setValue (0, UaDataValue (v, statusCode, srcTime, UaDateTime::now()), /*check access*/OpcUa_False  ) ;

}


UaStatus ASBuildInformation::getBuildTimestamp (UaString & r) const
{
    UaVariant v (* (m_BuildTimestamp->value(/*session*/0).value()));

    if (v.type() == OpcUaType_String)
    {
        r = v.toString();
        return OpcUa_Good;
    }
    else
        return OpcUa_Bad;

}

/* short getter (possible because this variable will never be null) */
UaString ASBuildInformation::getBuildTimestamp () const
{
    UaVariant v (* m_BuildTimestamp->value (0).value() );
    UaString v_value;
    v_value = v.toString();
    return v_value;
}


UaStatus ASBuildInformation::setCommitID (const UaString & value, OpcUa_StatusCode statusCode,const UaDateTime & srcTime )
{

    UaVariant v;

    v.setString( value );

    return m_CommitID->setValue (0, UaDataValue (v, statusCode, srcTime, UaDateTime::now()), /*check access*/OpcUa_False  ) ;

}


UaStatus ASBuildInformation::getCommitID (UaString & r) const
{
    UaVariant v (* (m_CommitID->value(/*session*/0).value()));

    if (v.type() == OpcUaType_String)
    {
        r = v.toString();
        return OpcUa_Good;
    }
    else
        return OpcUa_Bad;

}

/* short getter (possible because this variable will never be null) */
UaString ASBuildInformation::getCommitID () const
{
    UaVariant v (* m_CommitID->value (0).value() );
    UaString v_value;
    v_value = v.toString();
    return v_value;
}


UaStatus ASBuildInformation::setToolkitLibs (const UaString & value, OpcUa_StatusCode statusCode,const UaDateTime & srcTime )
{

    UaVariant v;

    v.setString( value );

    return m_ToolkitLibs->setValue (0, UaDataValue (v, statusCode, srcTime, UaDateTime::now()), /*check access*/OpcUa_False  ) ;

}


UaStatus ASBuildInformation::getToolkitLibs (UaString & r) const
{
    UaVariant v (* (m_ToolkitLibs->value(/*session*/0).value()));

    if (v.type() == OpcUaType_String)
    {
        r = v.toString();
        return OpcUa_Good;
    }
    else
        return OpcUa_Bad;

}

/* short getter (possible because this variable will never be null) */
UaString ASBuildInformation::getToolkitLibs () const
{
    UaVariant v (* m_ToolkitLibs->value (0).value() );
    UaString v_value;
    v_value = v.toString();
    return v_value;
}





/* generate delegates (if requested) */





/* generate device logic link */


void ASBuildInformation::linkDevice( Device::DBuildInformation *deviceLink)
{
    if (m_deviceLink != 0)
    {
        /* This is an error -- device can be linked at most in the object's lifetime. */
        //TODO After error handling is discussed, abort in smarter way
        abort();

    }
    else
        m_deviceLink = deviceLink;
}


void ASBuildInformation::unlinkDevice ()
{
    m_deviceLink = 0;
}


}

/* © Copyright CERN, 2015.  All rights not expressly granted are reserved.
 * ASComponentLogLevel.cpp
 *
 *  Created on: Aug 18, 2015
 * 	Author: Benjamin Farnham <benjamin.farnham@cern.ch>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <iostream>
#include <ASComponentLogLevel.h>
#include <DComponentLogLevel.h>

namespace AddressSpace
{

ASComponentLogLevel::ASComponentLogLevel (UaNodeId parentNodeId, const UaNodeId& typeNodeId, ASNodeManager *nm, const std::string& componentName, const std::string& logLevel)
:OpcUa::BaseObjectType (nm->makeChildNodeId(parentNodeId,componentName.c_str()), componentName.c_str(), nm->getNameSpaceIndex(), nm),
 m_typeNodeId (typeNodeId),
 m_logLevel (new ASDelegatingVariable<ASComponentLogLevel>(nm->makeChildNodeId(this->nodeId(),UaString("logLevel")), UaString("logLevel"), nm->getNameSpaceIndex(), UaVariant(logLevel.c_str()), OpcUa_AccessLevels_CurrentReadOrWrite, nm)),
 m_deviceLink (0)
{
    const UaStatus statusAddElementToParent = nm->addNodeAndReference( parentNodeId, this, OpcUaId_HasComponent);
    if (!statusAddElementToParent.isGood())
    {
        std::cout << "While addNodeAndReference from " << parentNodeId.toString().toUtf8() << " to " << this->nodeId().toString().toUtf8() << " : " << std::endl;
        ASSERT_GOOD(statusAddElementToParent);
    }

    UaVariant v;
    v.setString (logLevel.c_str());
    m_logLevel->setValue(/*pSession*/0, UaDataValue(UaVariant( v ), OpcUa_Good, UaDateTime::now(), UaDateTime::now() ), /*check access level*/OpcUa_False);

    UaStatus s = nm->addNodeAndReference(this, m_logLevel, OpcUaId_HasComponent);
    if (!s.isGood())
    {
        std::cout << "While addNodeAndReference from " << this->nodeId().toString().toUtf8() << " to " << m_logLevel->nodeId().toString().toUtf8() << " : " << std::endl;
        ASSERT_GOOD(s);
    }

    m_logLevel->assignHandler(this, &ASComponentLogLevel::writeLogLevel);
}

ASComponentLogLevel::~ASComponentLogLevel ()
{
    if (m_deviceLink != 0)
    {
        PRINT("deviceLink not zero!!");
        PRINT_LOCATION();
    }
}

/* generate setters and getters (if requested) */
UaStatus ASComponentLogLevel::setLogLevel (const UaString & value, OpcUa_StatusCode statusCode,const UaDateTime & srcTime )
{
    UaVariant v;
    v.setString( value );

    return m_logLevel->setValue (0, UaDataValue (v, statusCode, srcTime, UaDateTime::now()), /*check access*/OpcUa_False  ) ;
}

UaStatus ASComponentLogLevel::getLogLevel (UaString & r) const
{
    UaVariant v (* (m_logLevel->value(/*session*/0).value()));

    if (v.type() == OpcUaType_String)
    {
        r = v.toString();
        return OpcUa_Good;
    }
    else
        return OpcUa_Bad;
}

/* short getter (possible because this variable will never be null) */
UaString ASComponentLogLevel::getLogLevel () const
{
    UaVariant v (* m_logLevel->value (0).value() );
    UaString v_value;
    v_value = v.toString();
    return v_value;
}

/* generate delegates (if requested) */

/* NOTE: This function is not intended to be used by human being. */
UaStatus ASComponentLogLevel::writeLogLevel (Session* pSession, const UaDataValue& dataValue, OpcUa_Boolean checkAccessLevel)
{
    /* ensure that data type passed by OPC UA client matches specification */
    UaVariant v (*dataValue.value());
    if (v.type() != OpcUaType_String )
    {
        return OpcUa_BadDataEncodingInvalid;

        if (v.type() != OpcUaType_Null)
            return OpcUa_BadDataEncodingInvalid; // now we know it is neither the intended datatype nor NULL

    }
    UaString v_value(v.toString());

    /* if device logic type specified, then generate calling functions */

    if (m_deviceLink != 0)
    {
        return m_deviceLink->writeLogLevel(v_value);
    }
    else
        return OpcUa_Bad;
}


/* generate device logic link */
void ASComponentLogLevel::linkDevice( Device::DComponentLogLevel *deviceLink)
{
    if (m_deviceLink != 0)
    {
        /* This is an error -- device can be linked at most in the object's lifetime. */
        //TODO After error handling is discussed, abort in smarter way
        abort();
    }
    else
        m_deviceLink = deviceLink;
}


void ASComponentLogLevel::unlinkDevice ()
{
    m_deviceLink = 0;
}


}
/* © Copyright CERN, 2015.  All rights not expressly granted are reserved.
 * ASComponentLogLevels.cpp
 *
 *  Created on: Aug 18, 2015
 * 	Author: Benjamin Farnham <benjamin.farnham@cern.ch>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <iostream>
#include <ASComponentLogLevels.h>


namespace AddressSpace
{

ASComponentLogLevels::ASComponentLogLevels (UaNodeId parentNodeId, const UaNodeId& typeNodeId, ASNodeManager *nm)
:OpcUa::BaseObjectType (nm->makeChildNodeId(parentNodeId,"ComponentLogLevels"), "ComponentLogLevels", nm->getNameSpaceIndex(), nm),
 m_typeNodeId (typeNodeId)
{
    const UaStatus statusAddElementToParent = nm->addNodeAndReference( parentNodeId, this, OpcUaId_HasComponent);
    if (!statusAddElementToParent.isGood())
    {
        std::cout << "While addNodeAndReference from " << parentNodeId.toString().toUtf8() << " to " << this->nodeId().toString().toUtf8() << " : " << std::endl;
        ASSERT_GOOD(statusAddElementToParent);
    }
}

ASComponentLogLevels::~ASComponentLogLevels ()
{}

}

/* © Copyright CERN, 2015.  All rights not expressly granted are reserved.
 * ASGeneralLogLevel.cpp
 *
 *  Created on: Aug 18, 2015
 * 	Author: Benjamin Farnham <benjamin.farnham@cern.ch>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <iostream>




#include <ASGeneralLogLevel.h>


#include <DGeneralLogLevel.h>


namespace AddressSpace
{



/*ctr*/
ASGeneralLogLevel::ASGeneralLogLevel (
    UaNodeId parentNodeId,
    const UaNodeId& typeNodeId,
    ASNodeManager *nm,
	const std::string& logLevel)
:OpcUa::BaseObjectType (nm->makeChildNodeId(parentNodeId,"GeneralLogLevel"), "GeneralLogLevel", nm->getNameSpaceIndex(), nm),
 m_typeNodeId (typeNodeId),
 m_logLevel (new ASDelegatingVariable<ASGeneralLogLevel> (nm->makeChildNodeId(this->nodeId(),UaString("logLevel")), UaString("logLevel"), nm->getNameSpaceIndex(), UaVariant(logLevel.c_str()), OpcUa_AccessLevels_CurrentReadOrWrite , nm)),
 m_deviceLink (0)
{
    const UaStatus statusAddElementToParent = nm->addNodeAndReference( parentNodeId, this, OpcUaId_HasComponent);
    if (!statusAddElementToParent.isGood())
    {
        std::cout << "While addNodeAndReference from " << parentNodeId.toString().toUtf8() << " to " << this->nodeId().toString().toUtf8() << " : " << std::endl;
        ASSERT_GOOD(statusAddElementToParent);
    }

    UaVariant v;
    v.setString (logLevel.c_str());

    m_logLevel->setValue(/*pSession*/0, UaDataValue(UaVariant( v ), OpcUa_Good, UaDateTime::now(), UaDateTime::now() ), /*check access level*/OpcUa_False);

    const UaStatus s = nm->addNodeAndReference(this, m_logLevel, OpcUaId_HasComponent);
    if (!s.isGood())
    {
        std::cout << "While addNodeAndReference from " << this->nodeId().toString().toUtf8() << " to " << m_logLevel->nodeId().toString().toUtf8() << " : " << std::endl;
        ASSERT_GOOD(s);
    }

    m_logLevel->assignHandler(this, &ASGeneralLogLevel::writeLogLevel);
}

ASGeneralLogLevel::~ASGeneralLogLevel ()
{
    if (m_deviceLink != 0)
    {
        PRINT("deviceLink not zero!!");
        PRINT_LOCATION();
    }
}

UaStatus ASGeneralLogLevel::setLogLevel (const UaString & value, OpcUa_StatusCode statusCode,const UaDateTime & srcTime )
{
    UaVariant v;

    v.setString( value );

    return m_logLevel->setValue (0, UaDataValue (v, statusCode, srcTime, UaDateTime::now()), /*check access*/OpcUa_False  ) ;
}

UaStatus ASGeneralLogLevel::getLogLevel (UaString & r) const
{
    UaVariant v (* (m_logLevel->value(/*session*/0).value()));

    if (v.type() == OpcUaType_String)
    {
        r = v.toString();
        return OpcUa_Good;
    }
    else
        return OpcUa_Bad;
}


UaString ASGeneralLogLevel::getLogLevel () const
{
    UaVariant v (* m_logLevel->value (0).value() );
    UaString v_value;
    v_value = v.toString();
    return v_value;
}

UaStatus ASGeneralLogLevel::writeLogLevel (Session* pSession, const UaDataValue& dataValue, OpcUa_Boolean checkAccessLevel)
{
    /* ensure that data type passed by OPC UA client matches specification */
    UaVariant v (*dataValue.value());
    if (v.type() != OpcUaType_String )
    {
        return OpcUa_BadDataEncodingInvalid;

        if (v.type() != OpcUaType_Null)
            return OpcUa_BadDataEncodingInvalid; // now we know it is neither the intended datatype nor NULL
    }

    const UaString v_value(v.toString());

    if (m_deviceLink != 0)
    {
        return m_deviceLink->writeLogLevel(v_value);
    }
    else
        return OpcUa_Bad;
}

void ASGeneralLogLevel::linkDevice( Device::DGeneralLogLevel *deviceLink)
{
    if (m_deviceLink != 0)
    {
        /* This is an error -- device can be linked at most in the object's lifetime. */
        //TODO After error handling is discussed, abort in smarter way
        abort();

    }
    else
        m_deviceLink = deviceLink;
}


void ASGeneralLogLevel::unlinkDevice ()
{
    m_deviceLink = 0;
}


}

/* © Copyright CERN, 2015.  All rights not expressly granted are reserved.
 * ASLog.cpp
 *
 *  Created on: Aug 18, 2015
 * 	Author: Benjamin Farnham <benjamin.farnham@cern.ch>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <iostream>
#include <ASLog.h>


namespace AddressSpace
{

ASLog::ASLog (UaNodeId parentNodeId, const UaNodeId& typeNodeId, ASNodeManager *nm, const Configuration::Log & config)
:OpcUa::BaseObjectType (nm->makeChildNodeId(parentNodeId, "Log"), "Log", nm->getNameSpaceIndex(), nm),
 m_typeNodeId (typeNodeId)
{
    const UaStatus statusAddElementToParent = nm->addNodeAndReference( parentNodeId, this, OpcUaId_HasComponent);
    if (!statusAddElementToParent.isGood())
    {
        std::cout << "While addNodeAndReference from " << parentNodeId.toString().toUtf8() << " to " << this->nodeId().toString().toUtf8() << " : " << std::endl;
        ASSERT_GOOD(statusAddElementToParent);
    }
}

ASLog::~ASLog ()
{}

}

/* © Copyright CERN, Universidad de Oviedo, 2015.  All rights not expressly granted are reserved.
 * ASQuasar.cpp
 *
 *  Created on: Nov 5, 2015
 * 		Author: Damian Abalo Miron <damian.abalo@cern.ch>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <iostream>
#include <ASQuasar.h>
#include <DQuasar.h>

namespace AddressSpace
{



/*ctr*/
ASQuasar::ASQuasar (
    UaNodeId parentNodeId,
    const UaNodeId& typeNodeId,
    ASNodeManager *nm,
    const Configuration::Quasar & config):
    OpcUa::BaseObjectType (
        /*nodeId*/nm->makeChildNodeId(parentNodeId,"Quasar"), "Quasar", nm->getNameSpaceIndex(), nm),
    m_typeNodeId (typeNodeId)


    ,
    m_version (new

               OpcUa::BaseDataVariableType


               (nm->makeChildNodeId(this->nodeId(),UaString("version")), UaString("version"), nm->getNameSpaceIndex(), UaVariant(

                    UaString( "dummy version" )

                ),

                OpcUa_AccessLevels_CurrentRead
                , nm))



    ,
    m_deviceLink (0)


{
    UaStatus s;
    UaVariant v;

    s = nm->addNodeAndReference( parentNodeId, this, OpcUaId_HasComponent);
    if (!s.isGood())
    {
        std::cout << "While addNodeAndReference from " << parentNodeId.toString().toUtf8() << " to " << this->nodeId().toString().toUtf8() << " : " << std::endl;
        ASSERT_GOOD(s);
    }

    v.setString
    ( "dummy version" );

    m_version->setValue(/*pSession*/0, UaDataValue(UaVariant( v ),
                                    OpcUa_Good, UaDateTime::now(), UaDateTime::now() ), /*check access level*/OpcUa_False);

    s = nm->addNodeAndReference(this, m_version, OpcUaId_HasComponent);
    if (!s.isGood())
    {
        std::cout << "While addNodeAndReference from " << this->nodeId().toString().toUtf8() << " to " << m_version->nodeId().toString().toUtf8() << " : " << std::endl;
        ASSERT_GOOD(s);
    }



}





ASQuasar::~ASQuasar ()
{

    if (m_deviceLink != 0)
    {
        PRINT("deviceLink not zero!!");
        PRINT_LOCATION();

    }

}




/* generate setters and getters (if requested) */


UaStatus ASQuasar::setVersion (const UaString & value, OpcUa_StatusCode statusCode,const UaDateTime & srcTime )
{
    UaVariant v;

    v.setString( value );



    return m_version->setValue (0, UaDataValue (v, statusCode, srcTime, UaDateTime::now()), /*check access*/OpcUa_False  ) ;

}

UaStatus ASQuasar::getVersion (UaString & r) const
{
    UaVariant v (* (m_version->value(/*session*/0).value()));

    if (v.type() == OpcUaType_String)
    {
        r = v.toString();
        return OpcUa_Good;
    }
    else
        return OpcUa_Bad;

}


/* short getter (possible because this variable will never be null) */
UaString ASQuasar::getVersion () const
{
    UaVariant v (* m_version->value (0).value() );
    UaString v_value;
    v_value = v.toString();
    return v_value;
}





/* generate delegates (if requested) */





/* generate device logic link */


void ASQuasar::linkDevice( Device::DQuasar *deviceLink)
{
    if (m_deviceLink != 0)
    {
        /* This is an error -- device can be linked at most in the object's lifetime. */
        //TODO After error handling is discussed, abort in smarter way
        abort();

    }
    else
        m_deviceLink = deviceLink;
}


void ASQuasar::unlinkDevice ()
{
    m_deviceLink = 0;
}


}

/* © Copyright CERN, Universidad de Oviedo, 2015.  All rights not expressly granted are reserved.
 * ASServer.cpp
 *
 *  Created on: Nov 5, 2015
 * 		Author: Damian Abalo Miron <damian.abalo@cern.ch>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <iostream>
#include <ASServer.h>
#include <DServer.h>

namespace AddressSpace
{



/*ctr*/
ASServer::ASServer (
    UaNodeId parentNodeId,
    const UaNodeId& typeNodeId,
    ASNodeManager *nm,
    const Configuration::Server & config):
    OpcUa::BaseObjectType (
        /*nodeId*/nm->makeChildNodeId(parentNodeId,"Server"), "Server", nm->getNameSpaceIndex(), nm),
    m_typeNodeId (typeNodeId)


    ,
	m_remainingCertificateValidity (new

                            OpcUa::BaseDataVariableType


                            (nm->makeChildNodeId(this->nodeId(),UaString("remainingCertificateValidity")), UaString("remainingCertificateValidity"), nm->getNameSpaceIndex(), UaVariant(

                            		UaString( "unknown" )

                             ),

                             OpcUa_AccessLevels_CurrentRead
                             , nm))



    ,
    m_deviceLink (0)


{
    UaStatus s;
    UaVariant v;

    s = nm->addNodeAndReference( parentNodeId, this, OpcUaId_HasComponent);
    if (!s.isGood())
    {
        std::cout << "While addNodeAndReference from " << parentNodeId.toString().toUtf8() << " to " << this->nodeId().toString().toUtf8() << " : " << std::endl;
        ASSERT_GOOD(s);
    }

    v.setString("uninitialized");
    m_remainingCertificateValidity->setValue(/*pSession*/0, UaDataValue(UaVariant( v ),
                                    OpcUa_Good, UaDateTime::now(), UaDateTime::now() ), /*check access level*/OpcUa_False);

    s = nm->addNodeAndReference(this, m_remainingCertificateValidity, OpcUaId_HasComponent);
    if (!s.isGood())
    {
        std::cout << "While addNodeAndReference from " << this->nodeId().toString().toUtf8() << " to " << m_remainingCertificateValidity->nodeId().toString().toUtf8() << " : " << std::endl;
        ASSERT_GOOD(s);
    }
}





ASServer::~ASServer ()
{

    if (m_deviceLink != 0)
    {
        PRINT("deviceLink not zero!!");
        PRINT_LOCATION();

    }

}




/* generate setters and getters (if requested) */



UaStatus ASServer::setRemainingCertificateValidity(const UaString& value, OpcUa_StatusCode statusCode,const UaDateTime & srcTime )
{
    UaVariant v;

    v.setString( value );



    return m_remainingCertificateValidity->setValue (0, UaDataValue (v, statusCode, srcTime, UaDateTime::now()), /*check access*/OpcUa_False  ) ;

}

UaStatus ASServer::getRemainingCertificateValidity(UaString & r) const
{
    UaVariant v (* (m_remainingCertificateValidity->value(/*session*/0).value()));

    if (v.type() == OpcUaType_String)
    {
        r = v.toString();
        return OpcUa_Good;
    }
    else
        return OpcUa_Bad;
}

/* short getter (possible because nullPolicy=nullForbidden) */
UaString ASServer::getRemainingCertificateValidity() const
{
    UaVariant v (* m_remainingCertificateValidity->value (0).value() );
    UaString v_value;
    v_value = v.toString();
    return v_value;
}




/* generate delegates (if requested) */





/* generate device logic link */


void ASServer::linkDevice( Device::DServer *deviceLink)
{
    if (m_deviceLink != 0)
    {
        /* This is an error -- device can be linked at most in the object's lifetime. */
        //TODO After error handling is discussed, abort in smarter way
        abort();

    }
    else
        m_deviceLink = deviceLink;
}


void ASServer::unlinkDevice ()
{
    m_deviceLink = 0;
}


}

/* © Copyright CERN, 2015.  All rights not expressly granted are reserved.
 * ASSourceVariableThreadPool.cpp
 *
 *  Created on: Aug 18, 2015
 * 	Author: Benjamin Farnham <benjamin.farnham@cern.ch>
 *      Author: Piotr Nikiel <piotr@nikiel.info>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <iostream>




#include <ASSourceVariableThreadPool.h>


#include <DSourceVariableThreadPool.h>


namespace AddressSpace
{



/*ctr*/
ASSourceVariableThreadPool::ASSourceVariableThreadPool (
    UaNodeId parentNodeId,
    const UaNodeId& typeNodeId,
    ASNodeManager *nm,
    const size_t& min,
	const size_t& max):
    OpcUa::BaseObjectType (
    /*nodeId*/nm->makeChildNodeId(parentNodeId,"SourceVariableThreadPool"), "SourceVariableThreadPool", nm->getNameSpaceIndex(), nm),
    m_typeNodeId (typeNodeId)


    ,
    m_minThreads (new

                  OpcUa::BaseDataVariableType


                  (nm->makeChildNodeId(this->nodeId(),UaString("minThreads")), UaString("minThreads"), nm->getNameSpaceIndex(), UaVariant(

                       static_cast<OpcUa_UInt32>(min)
                   ),

                   OpcUa_AccessLevels_CurrentRead
                   , nm))



    ,
    m_maxThreads (new

                  OpcUa::BaseDataVariableType


                  (nm->makeChildNodeId(this->nodeId(),UaString("maxThreads")), UaString("maxThreads"), nm->getNameSpaceIndex(), UaVariant(

                		  static_cast<OpcUa_UInt32>(max)
                   ),

                   OpcUa_AccessLevels_CurrentRead
                   , nm))



    ,
    m_deviceLink (0)


{
    UaStatus s;
    UaVariant v;

    s = nm->addNodeAndReference( parentNodeId, this, OpcUaId_HasComponent);
    if (!s.isGood())
    {
        std::cout << "While addNodeAndReference from " << parentNodeId.toString().toUtf8() << " to " << this->nodeId().toString().toUtf8() << " : " << std::endl;
        ASSERT_GOOD(s);
    }

    v.setUInt32 (
    		static_cast<OpcUa_UInt32>(min)
    );
    m_minThreads->setValue(/*pSession*/0, UaDataValue(UaVariant( v ), OpcUa_Good, UaDateTime::now(), UaDateTime::now() ), /*check access level*/OpcUa_False);

    s = nm->addNodeAndReference(this, m_minThreads, OpcUaId_HasComponent);
    if (!s.isGood())
    {
        std::cout << "While addNodeAndReference from " << this->nodeId().toString().toUtf8() << " to " << m_minThreads->nodeId().toString().toUtf8() << " : " << std::endl;
        ASSERT_GOOD(s);
    }


    v.setUInt32 (
    		static_cast<OpcUa_UInt32>(max)
    );
    m_maxThreads->setValue(/*pSession*/0, UaDataValue(UaVariant( v ), OpcUa_Good, UaDateTime::now(), UaDateTime::now() ), /*check access level*/OpcUa_False);

    s = nm->addNodeAndReference(this, m_maxThreads, OpcUaId_HasComponent);
    if (!s.isGood())
    {
        std::cout << "While addNodeAndReference from " << this->nodeId().toString().toUtf8() << " to " << m_maxThreads->nodeId().toString().toUtf8() << " : " << std::endl;
        ASSERT_GOOD(s);
    }



}





ASSourceVariableThreadPool::~ASSourceVariableThreadPool ()
{

    if (m_deviceLink != 0)
    {
        PRINT("deviceLink not zero!!");
        PRINT_LOCATION();

    }

}




/* generate setters and getters (if requested) */


UaStatus ASSourceVariableThreadPool::setMinThreads (const OpcUa_UInt32 value, OpcUa_StatusCode statusCode,const UaDateTime & srcTime )
{
    UaVariant v;

    v.setUInt32( value );



    return m_minThreads->setValue (0, UaDataValue (v, statusCode, srcTime, UaDateTime::now()), /*check access*/OpcUa_False  ) ;

}

UaStatus ASSourceVariableThreadPool::getMinThreads (OpcUa_UInt32 & r) const
{
    UaVariant v (* (m_minThreads->value(/*session*/0).value()));
    return v.toUInt32 ( r );
}


/* short getter (possible because this variable will never be null) */
OpcUa_UInt32 ASSourceVariableThreadPool::getMinThreads () const
{
    UaVariant v (* m_minThreads->value (0).value() );
    OpcUa_UInt32 v_value;
    v.toUInt32 ( v_value );
    return v_value;
}


UaStatus ASSourceVariableThreadPool::setMaxThreads (const OpcUa_UInt32 value, OpcUa_StatusCode statusCode,const UaDateTime & srcTime )
{
    UaVariant v;

    v.setUInt32( value );



    return m_maxThreads->setValue (0, UaDataValue (v, statusCode, srcTime, UaDateTime::now()), /*check access*/OpcUa_False  ) ;

}

UaStatus ASSourceVariableThreadPool::getMaxThreads (OpcUa_UInt32 & r) const
{
    UaVariant v (* (m_maxThreads->value(/*session*/0).value()));
    return v.toUInt32 ( r );
}


/* short getter (possible because this variable will never be null) */
OpcUa_UInt32 ASSourceVariableThreadPool::getMaxThreads () const
{
    UaVariant v (* m_maxThreads->value (0).value() );
    OpcUa_UInt32 v_value;
    v.toUInt32 ( v_value );
    return v_value;
}





/* generate delegates (if requested) */





/* generate device logic link */


void ASSourceVariableThreadPool::linkDevice( Device::DSourceVariableThreadPool *deviceLink)
{
    if (m_deviceLink != 0)
    {
        /* This is an error -- device can be linked at most in the object's lifetime. */
        //TODO After error handling is discussed, abort in smarter way
        abort();

    }
    else
        m_deviceLink = deviceLink;
}


void ASSourceVariableThreadPool::unlinkDevice ()
{
    m_deviceLink = 0;
}


}

/* © Copyright CERN, 2015.  All rights not expressly granted are reserved.
 * ASStandardMetaData.cpp
 *
 *  Created on: Aug 18, 2015
 *	Author: Benjamin Farnham <benjamin.farnham@cern.ch>
 *      Author: Piotr Nikiel <piotr@nikiel.info>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <iostream>




#include <ASStandardMetaData.h>


#include <DStandardMetaData.h>


namespace AddressSpace
{



/*ctr*/
ASStandardMetaData::ASStandardMetaData (
    UaNodeId parentNodeId,
    const UaNodeId& typeNodeId,
    ASNodeManager *nm,
    const Configuration::StandardMetaData & config):
    OpcUa::BaseObjectType (nm->makeChildNodeId(parentNodeId,"StandardMetaData"), "StandardMetaData", nm->getNameSpaceIndex(), nm),
    m_typeNodeId (typeNodeId)


    ,
    m_deviceLink (0)


{
    UaStatus s;
    UaVariant v;


}





ASStandardMetaData::~ASStandardMetaData ()
{

    if (m_deviceLink != 0)
    {
        PRINT("deviceLink not zero!!");
        PRINT_LOCATION();

    }

}




/* generate setters and getters (if requested) */





/* generate delegates (if requested) */





/* generate device logic link */


void ASStandardMetaData::linkDevice( Device::DStandardMetaData *deviceLink)
{
    if (m_deviceLink != 0)
    {
        /* This is an error -- device can be linked at most in the object's lifetime. */
        //TODO After error handling is discussed, abort in smarter way
        abort();

    }
    else
        m_deviceLink = deviceLink;
}


void ASStandardMetaData::unlinkDevice ()
{
    m_deviceLink = 0;
}


}


/*  © Copyright CERN, 2015. All rights not expressly granted are reserved.
    Authors(from Quasar team): Piotr Nikiel

    This file is part of Quasar.

    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.

    This file was completely generated by Quasar (additional info: using transform designToDeviceBaseBody.xslt)
    on 2018-11-09T17:06:14.522+01:00
 */




#include <Configuration.hxx>


#include <Base_DBuildInformation.h>







namespace Device
{



void Base_DBuildInformation::linkAddressSpace( AddressSpace::ASBuildInformation *addressSpaceLink)
{
    if (m_addressSpaceLink != 0)
    {
        /* signalize nice error from here. */
        abort();
    }
    else
        m_addressSpaceLink = addressSpaceLink;
}

/* add/remove */


//! Disconnects AddressSpace part from the Device logic, and does the same for all children
//! Returns number of unlinked objects including self
unsigned int Base_DBuildInformation::unlinkAllChildren ()
{
    unsigned int objectCounter=1;  // 1 is for self
    m_addressSpaceLink = 0;
    /* Fill up: call unlinkAllChildren on all children */

    return objectCounter;

}


/* find methods for children */






/* Constructor */
Base_DBuildInformation::Base_DBuildInformation ()
:m_addressSpaceLink(0)
{}

Base_DBuildInformation::~Base_DBuildInformation ()
{
    /* remove children */

}



std::list<DBuildInformation*> Base_DBuildInformation::s_orphanedObjects;




}


/* © Copyright CERN, 2015.  All rights not expressly granted are reserved.
 * Base_DComponentLogLevel.cpp
 *
 *  Created on: Aug 18, 2015
 * 	Author: Benjamin Farnham <benjamin.farnham@cern.ch>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <Configuration.hxx>
#include <Base_DComponentLogLevel.h>
#include <ASComponentLogLevel.h>

namespace Device
{

void Base_DComponentLogLevel::linkAddressSpace( AddressSpace::ASComponentLogLevel *addressSpaceLink)
{
    if (m_addressSpaceLink != 0)
    {
        /* signalize nice error from here. */
        abort();
    }
    else
        m_addressSpaceLink = addressSpaceLink;
}

//! Disconnects AddressSpace part from the Device logic, and does the same for all children
//! Returns number of unlinked objects including self
unsigned int Base_DComponentLogLevel::unlinkAllChildren ()
{
    unsigned int objectCounter=1;  // 1 is for self
    m_addressSpaceLink = 0;
    /* Fill up: call unlinkAllChildren on all children */

    return objectCounter;
}

Base_DComponentLogLevel::Base_DComponentLogLevel ()
:m_addressSpaceLink(0)
{}

Base_DComponentLogLevel::~Base_DComponentLogLevel ()
{}

std::string Base_DComponentLogLevel::getFullName() const
{
    if (m_addressSpaceLink)
    {
        return std::string(m_addressSpaceLink->nodeId().toFullString().toUtf8());
    }
    else
        return "-ObjectNotBoundToAddressSpace-";
}

}
/* © Copyright CERN, 2015.  All rights not expressly granted are reserved.
 * Base_DGeneralLogLevel.cpp
 *
 *  Created on: Aug 18, 2015
 * 	Author: Benjamin Farnham <benjamin.farnham@cern.ch>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <Configuration.hxx>


#include <Base_DGeneralLogLevel.h>
#include <ASGeneralLogLevel.h>






namespace Device
{


void Base_DGeneralLogLevel::linkAddressSpace( AddressSpace::ASGeneralLogLevel *addressSpaceLink)
{
    if (m_addressSpaceLink != 0)
    {
        /* signalize nice error from here. */
        abort();
    }
    else
        m_addressSpaceLink = addressSpaceLink;
}

/* add/remove */


//! Disconnects AddressSpace part from the Device logic, and does the same for all children
//! Returns number of unlinked objects including self
unsigned int Base_DGeneralLogLevel::unlinkAllChildren ()
{
    unsigned int objectCounter=1;  // 1 is for self
    m_addressSpaceLink = 0;
    /* Fill up: call unlinkAllChildren on all children */

    return objectCounter;

}

/* find methods for children */





/* Constructor */
Base_DGeneralLogLevel::Base_DGeneralLogLevel ()
:m_addressSpaceLink(0)
{}

Base_DGeneralLogLevel::~Base_DGeneralLogLevel ()
{}

std::string Base_DGeneralLogLevel::getFullName() const
{
    if (m_addressSpaceLink)
    {
        return std::string(m_addressSpaceLink->nodeId().toFullString().toUtf8());
    }
    else
        return "-ObjectNotBoundToAddressSpace-";
}




}


/* © Copyright CERN, Universidad de Oviedo, 2015.  All rights not expressly granted are reserved.
 * Base_DQuasar.cpp
 *
 *  Created on: Nov 5, 2015
 * 		Author: Damian Abalo Miron <damian.abalo@cern.ch>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <Configuration.hxx>


#include <Base_DQuasar.h>
#include <ASQuasar.h>






namespace Device
{


void Base_DQuasar::linkAddressSpace( AddressSpace::ASQuasar *addressSpaceLink)
{
    if (m_addressSpaceLink != 0)
    {
        /* signalize nice error from here. */
        abort();
    }
    else
        m_addressSpaceLink = addressSpaceLink;
}

/* add/remove */


//! Disconnects AddressSpace part from the Device logic, and does the same for all children
//! Returns number of unlinked objects including self
unsigned int Base_DQuasar::unlinkAllChildren ()
{
    unsigned int objectCounter=1;  // 1 is for self
    m_addressSpaceLink = 0;
    /* Fill up: call unlinkAllChildren on all children */

    return objectCounter;

}

/* find methods for children */





/* Constructor */
Base_DQuasar::Base_DQuasar (const Configuration::Quasar & config

                            , DRoot * parent

                           ):

    m_parent(parent),

    m_addressSpaceLink(0)

{

}

Base_DQuasar::~Base_DQuasar ()
{
    /* remove children */

}

std::string Base_DQuasar::getFullName() const
{
    if (m_addressSpaceLink)
    {
        return std::string(m_addressSpaceLink->nodeId().toFullString().toUtf8());
    }
    else
        return "-ObjectNotBoundToAddressSpace-";
}




}


/* © Copyright CERN, Universidad de Oviedo, 2015.  All rights not expressly granted are reserved.
 * Base_DServer.cpp
 *
 *  Created on: Nov 5, 2015
 * 		Author: Damian Abalo Miron <damian.abalo@cern.ch>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <Configuration.hxx>


#include <Base_DServer.h>
#include <ASServer.h>






namespace Device
{


void Base_DServer::linkAddressSpace( AddressSpace::ASServer *addressSpaceLink)
{
    if (m_addressSpaceLink != 0)
    {
        /* signalize nice error from here. */
        abort();
    }
    else
        m_addressSpaceLink = addressSpaceLink;
}

/* add/remove */


//! Disconnects AddressSpace part from the Device logic, and does the same for all children
//! Returns number of unlinked objects including self
unsigned int Base_DServer::unlinkAllChildren ()
{
    unsigned int objectCounter=1;  // 1 is for self
    m_addressSpaceLink = 0;
    /* Fill up: call unlinkAllChildren on all children */

    return objectCounter;

}

/* find methods for children */





/* Constructor */
Base_DServer::Base_DServer (const Configuration::Server & config

                            , DRoot * parent

                           ):

    m_parent(parent),

    m_addressSpaceLink(0)

{

}

Base_DServer::~Base_DServer ()
{
    /* remove children */

}

std::string Base_DServer::getFullName() const
{
    if (m_addressSpaceLink)
    {
        return std::string(m_addressSpaceLink->nodeId().toFullString().toUtf8());
    }
    else
        return "-ObjectNotBoundToAddressSpace-";
}




}


/* © Copyright CERN, 2015.  All rights not expressly granted are reserved.
 * Base_DSourceVariableThreadPool.cpp
 *
 *  Created on: Aug 18, 2015
 * 	Author: Benjamin Farnham <benjamin.farnham@cern.ch>
 *      Author: Piotr Nikiel <piotr@nikiel.info>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <Configuration.hxx>


#include <Base_DSourceVariableThreadPool.h>
#include <ASSourceVariableThreadPool.h>






namespace Device
{


void Base_DSourceVariableThreadPool::linkAddressSpace( AddressSpace::ASSourceVariableThreadPool *addressSpaceLink)
{
    if (m_addressSpaceLink != 0)
    {
        /* signalize nice error from here. */
        abort();
    }
    else
        m_addressSpaceLink = addressSpaceLink;
}

/* add/remove */


//! Disconnects AddressSpace part from the Device logic, and does the same for all children
//! Returns number of unlinked objects including self
unsigned int Base_DSourceVariableThreadPool::unlinkAllChildren ()
{
    unsigned int objectCounter=1;  // 1 is for self
    m_addressSpaceLink = 0;
    /* Fill up: call unlinkAllChildren on all children */

    return objectCounter;

}

/* find methods for children */





/* Constructor */
Base_DSourceVariableThreadPool::Base_DSourceVariableThreadPool ()
:m_addressSpaceLink(0)
{}

Base_DSourceVariableThreadPool::~Base_DSourceVariableThreadPool ()
{}

std::string Base_DSourceVariableThreadPool::getFullName() const
{
    if (m_addressSpaceLink)
    {
        return std::string(m_addressSpaceLink->nodeId().toFullString().toUtf8());
    }
    else
        return "-ObjectNotBoundToAddressSpace-";
}




}


/* © Copyright CERN, 2015.  All rights not expressly granted are reserved.
 * Base_DStandardMetaData.cpp
 *
 *  Created on: Aug 18, 2015
 * 	Author: Benjamin Farnham <benjamin.farnham@cern.ch>
 *      Author: Piotr Nikiel <piotr@nikiel.info>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <Configuration.hxx>
#include <Base_DStandardMetaData.h>
#include <ASStandardMetaData.h>

namespace Device
{


void Base_DStandardMetaData::linkAddressSpace( AddressSpace::ASStandardMetaData *addressSpaceLink)
{
    if (m_addressSpaceLink != 0)
    {
        /* signalize nice error from here. */
        abort();
    }
    else
        m_addressSpaceLink = addressSpaceLink;
}

//! Disconnects AddressSpace part from the Device logic, and does the same for all children
//! Returns number of unlinked objects including self
unsigned int Base_DStandardMetaData::unlinkAllChildren ()
{
    return 1;
}

Base_DStandardMetaData::Base_DStandardMetaData (const Configuration::StandardMetaData & config, DRoot * parent)
:m_parent(parent),  m_addressSpaceLink(0)
{}

Base_DStandardMetaData::~Base_DStandardMetaData ()
{}

std::string Base_DStandardMetaData::getFullName() const
{
    if (m_addressSpaceLink)
    {
        return std::string(m_addressSpaceLink->nodeId().toFullString().toUtf8());
    }
    else
        return "-ObjectNotBoundToAddressSpace-";
}

}


/*
 * Certificate.cpp
 *
 *  Created on: Jun 29, 2016
 *      Author: mludwig
 */

using namespace std;

#include <iomanip>

#include <Certificate.h>
#include <boost/date_time.hpp>

#include <LogIt.h>
#include <LogLevels.h>

// singleton
Certificate* Certificate::_pInstance = NULL;

const std::string Certificate::DEFAULT_PUBLIC_CERT_FILENAME("./PKI/CA/certs/OpcUaServer.der");
const std::string Certificate::DEFAULT_PRIVATE_CERT_FILENAME("./PKI/CA/private/OpcUaServer.pem");

Certificate* Certificate::Instance( string certfn, string privkeyfn, enum behaviour_t beh )
{
	if (!_pInstance)   // Only allow one instance of class to be generated.
		_pInstance = new Certificate( certfn, privkeyfn, beh );
	return _pInstance;
}

Certificate* Certificate::Instance( )
{
	if(!_pInstance)
	{
		throw std::logic_error("No Certificate singleton instance has been instantiated, programming error.");
	}
	return _pInstance;
}

Certificate::Certificate( string certfn, string privkeyfn, enum behaviour_t beh  )
:m_certfn(certfn), m_privkeyfn(privkeyfn), m_behaviour(beh), m_ssl(NULL), m_time_end(0), m_status(STATUS_UNKNOWN), m_remaining_validity_in_seconds(0)
// :m_certfn(certfn), m_privkeyfn(privkeyfn), m_behaviour(beh), m_ssl(NULL), m_time_end(NULL), m_status(STATUS_UNKNOWN), m_remaining_validity_in_seconds(0)
{
	setTypeDER();

	if (m_behaviour != BEHAVIOR_NONE )
	{
		SSL_load_error_strings();            /* readable error messages */
		SSL_library_init();                  /* initialize library */
	}
}

Certificate::~Certificate()
{
	if(m_ssl) SSL_shutdown( m_ssl );
}

int Certificate::validateCertificateFilename(const std::string& certificateFilename) const
{
	if ( m_privkeyfn.length() < 5 )
	{
		LOG(Log::ERR) << "refuse to open certificate " << m_privkeyfn << " : filename seems to short ( \"a.der\" at least )";
		return -2;
	}
	ifstream ftest;
	string line;
	ftest.open ( m_privkeyfn.c_str() );
	if ( ftest.is_open() )	{
		while ( getline (ftest ,line) )	{
			// cout << __FILE__ << " " << __LINE__ << " line= " << line << endl;
		}
		ftest.close();
	} else {
		LOG(Log::ERR) << "unable to open file  " << m_privkeyfn;
		return -1;
	}

	return 0;
}

/// loads one private key
int Certificate::loadPrivateKeyFromFile( void )
{
	const int certificateFileCheckResult = validateCertificateFilename(m_privkeyfn);
	if(certificateFileCheckResult < 0) return certificateFileCheckResult;

	m_ssl = SSL_new( SSL_CTX_new( SSLv23_method() ) );
	SSL_use_PrivateKey_file( m_ssl, m_privkeyfn.c_str(), m_type);
	return( 0 );
}

/// loads one PEM file with one certificate, no chain, no CA
int Certificate::loadCertificateFromFile( void )
{
	const int certificateFileCheckResult = validateCertificateFilename(m_certfn);
	if(certificateFileCheckResult < 0) return certificateFileCheckResult;

	m_ssl = SSL_new( SSL_CTX_new( SSLv23_method() ) );
	SSL_use_certificate_file( m_ssl, m_certfn.c_str(), m_type);
	// or like this, including a CA
	// SSL_CTX_use_certificate_chain_file( _ssl_ctx, fname.c_str() );
	X509 *x509crt = SSL_get_certificate( m_ssl );

	// validity format is here:
	// https://github.com/openssl/openssl/commit/f48b83b4fb7d6689584cf25f61ca63a4891f5b11

	// in fact these are strings in UTC format, need to convert them into time_t to become useful
	m_time_end = _timeASN1toTIME_T(  X509_get_notAfter(x509crt) );
	
	remainingValidityTime();
	LOG(Log::INF) << " certificate remaining time= " << remainingDays() << "days "
			<< remainingHours() << ":"
			<< remainingMins() << ":"
			<< remainingSecs();
	return( 0 );
}


void Certificate::remainingValidityTime( void ){
	const tm now = boost::posix_time::to_tm(boost::posix_time::second_clock::local_time());
//	time_t t = time( 0 );
//	struct tm * now = localtime( &t );
	ASN1_TIME asn1now;
	asn1now.type = V_ASN1_UTCTIME;
	stringstream ss;
	string fmon = "";
	if ( now.tm_mon +1 < 10 ) fmon = "0";
	string fday = "";
	if ( now.tm_mday < 10 ) fday = "0";
	string fhour = "";
	if ( now.tm_hour < 10 ) fhour = "0";
	string fmin = "";
	if ( now.tm_min < 10 ) fmin = "0";
	string fsec = "";
	if ( now.tm_sec < 10 ) fsec = "0";

	ss << now.tm_year - 100
			<< fmon << now.tm_mon +1
			<< fday << now.tm_mday
			<< fhour << now.tm_hour
			<< fmin << now.tm_min
			<< fsec << now.tm_sec << "Z";

	string asn1str = ss.str();
	//cout << __FILE__ << " " << __LINE__ << " asn1str= " << asn1str << endl;
	asn1now.data = (unsigned char *) ( asn1str.c_str() );
	std::time_t time_now = _timeASN1toTIME_T( &asn1now );

	m_remaining_validity_in_seconds = ( int64_t ) difftime( m_time_end, time_now ); // seconds as int
}

int Certificate::remainingDays( void ) const
{
	return m_remaining_validity_in_seconds / 86400;
}

int Certificate::remainingHours( void ) const
{
	return (m_remaining_validity_in_seconds - (remainingDays()*86400) ) / 3600;
}

int Certificate::remainingMins( void ) const
{
	return (m_remaining_validity_in_seconds - (remainingDays()*86400) - (remainingHours()*3600) ) / 60;
}

int Certificate::remainingSecs( void ) const
{
	return m_remaining_validity_in_seconds - (remainingDays()*86400) - (remainingHours()*3600) - (remainingMins()*60);;
}

// validity format is here:
// https://github.com/openssl/openssl/commit/f48b83b4fb7d6689584cf25f61ca63a4891f5b11
time_t Certificate::_timeASN1toTIME_T( ASN1_TIME* time )
{
	struct tm t;
	memset( (void*)&t, 0, sizeof t);
	string str ( (const char *) time->data );
	size_t i = 0;
	/*
	    OPCServerCertificate.cpp 150 str= 160822103554Z
	    OPCServerCertificate.cpp 153 V_ASN1_UTCTIME
	    OPCServerCertificate.cpp 150 str= 160606103554Z
	    OPCServerCertificate.cpp 153 V_ASN1_UTCTIME
	 */
	if (time->type == V_ASN1_UTCTIME) {/* two digit year */
		//cout << __FILE__ << " " << __LINE__ << " V_ASN1_UTCTIME" << endl;
		t.tm_year  = std::atoi( str.substr(0, 2).c_str() ) + 2000;
		//cout << __FILE__ << " " << __LINE__ << " tm_year= " << t.tm_year << endl;
		i = 2;
	} else if (time->type == V_ASN1_GENERALIZEDTIME) {/* four digit year */
		//cout << __FILE__ << " " << __LINE__ << " V_ASN1_GENERALIZEDTIME" << endl;
		t.tm_year  = std::atoi( str.substr(0, 4).c_str() );
		//cout << __FILE__ << " " << __LINE__ << "tm_year= " << t.tm_year << endl;
		i = 4;
	}
	t.tm_mon   = std::atoi( str.substr(i, 2).c_str() ) - 1; // -1 since January is 0 not 1.
	i += 2;
	t.tm_mday  = std::atoi( str.substr(i, 2).c_str() );
	i += 2;
	t.tm_hour  = std::atoi( str.substr(i, 2).c_str() );
	i += 2;
	t.tm_min  = std::atoi( str.substr(i, 2).c_str() );
	i += 2;
	t.tm_sec  = std::atoi( str.substr(i, 2).c_str() );
	return mktime(&t);
}

// ===== PUBLIC ======

int Certificate::init( void ){
	int ret = 0;
	switch ( m_behaviour ) {
	case BEHAVIOR_NONE: {
		m_status = Certificate::STATUS_OK;
		break;
	}
	case BEHAVIOR_TRY: {
		ret = Certificate::loadCertificateFromFile();
		m_status = ret < 0 ? Certificate::STATUS_FAILED : Certificate::STATUS_OK;
		break;
	}
	case BEHAVIOR_TRYCA:
	case BEHAVIOR_CERT:
	case BEHAVIOR_CERTCA:{
		m_status = Certificate::STATUS_UNKNOWN;
		break;
	}
	} // switch
	return( ret );
}

string Certificate::remainingTime( void ){
	if ( m_behaviour == BEHAVIOR_NONE )
		return( "SSL NOT INITIALIZED" );
	if (( m_behaviour == BEHAVIOR_TRY ) && ( m_status == Certificate::STATUS_FAILED ))
		return( "Not Applicable: No Certificate Found" );

	if ( m_status == Certificate::STATUS_FAILED ){
		LOG(Log::ERR) << "certificate status failed, a problem occurred";
		return( "CERTIFICATE STATUS FAILED" );
	}
	if ( m_status == Certificate::STATUS_UNKNOWN ){
		return( "CERTIFICATE STATUS UNKNOWN" );
	}
	remainingValidityTime();
	stringstream xx;
	xx << remainingDays() << string("days ") <<
			setfill('0') << setw(2) << remainingHours() << ":" <<
			setfill('0') << setw(2) << remainingMins() << ":" <<
			setfill('0') << setw(2) << remainingSecs();
	return( xx.str() );
}

/*  © Copyright CERN, 2015. All rights not expressly granted are reserved.

    The stub of this file was generated by Quasar (additional info: using transform designToDeviceBody.xslt)
    on 2018-11-09T17:04:50.174+01:00

    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.



 */




#include <Configuration.hxx>

#include <DBuildInformation.h>
#include <ASBuildInformation.h>





namespace Device
{




// 1111111111111111111111111111111111111111111111111111111111111111111111111
// 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
// 1     Users don't modify this code!!!!                                  1
// 1     If you modify this code you may start a fire or a flood somewhere,1
// 1     and some human being may possible cease to exist. You don't want  1
// 1     to be charged with that!                                          1
// 1111111111111111111111111111111111111111111111111111111111111111111111111






// 2222222222222222222222222222222222222222222222222222222222222222222222222
// 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
// 2     (code for which only stubs were generated automatically)          2
// 2     You should add the implementation but dont alter the headers      2
// 2     (apart from constructor, in which you should complete initializati2
// 2     on list)                                                          2
// 2222222222222222222222222222222222222222222222222222222222222222222222222

/* sample ctr */
DBuildInformation::DBuildInformation (const std::string& host, const std::string& timestamp, const std::string& commitID, const std::string& toolkitLibs)
{
}

/* sample dtr */
DBuildInformation::~DBuildInformation ()
{
}

/* delegators for cachevariables and externalvariables */


// 3333333333333333333333333333333333333333333333333333333333333333333333333
// 3     FULLY CUSTOM CODE STARTS HERE                                     3
// 3     Below you put bodies for custom methods defined for this class.   3
// 3     You can do whatever you want, but please be decent.               3
// 3333333333333333333333333333333333333333333333333333333333333333333333333




}


/* © Copyright CERN, 2015.  All rights not expressly granted are reserved.
 * DComponentLogLevel.cpp
 *
 *  Created on: Aug 18, 2015
 * 		Author: Benjamin Farnham <benjamin.farnham@cern.ch>
 *      Author: Piotr Nikiel <piotr@nikiel.info>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <Configuration.hxx>
#include <DComponentLogLevel.h>
#include <ASComponentLogLevel.h>
#include <LogIt.h>
#include <LogLevels.h>

namespace Device
{
DComponentLogLevel::DComponentLogLevel (const Log::LogComponentHandle& componentHandle, const std::string& logLevel)
:Base_DComponentLogLevel(), m_loggingComponentId(componentHandle), m_loggingComponentName(Log::getComponentName(componentHandle))
{
	writeLogLevel(logLevel.c_str());
}

DComponentLogLevel::~DComponentLogLevel ()
{}

UaStatus DComponentLogLevel::writeLogLevel ( const UaString & v)
{
	Log::LOG_LEVEL targetLevel;
	if(Log::logLevelFromString(v.toUtf8(), targetLevel))
	{
		if(Log::setComponentLogLevel(m_loggingComponentId, targetLevel))
		{
			LOG(Log::INF) << "setting component [name:"<<m_loggingComponentName<<" id:"<<m_loggingComponentId<<"] to level ["<<Log::logLevelToString(targetLevel)<<"]";
			return OpcUa_Good;
		}
		else
		{
			LOG(Log::WRN) << "failed to set component [name:"<<m_loggingComponentName<<" id:"<<m_loggingComponentId<<"] to level ["<<Log::logLevelToString(targetLevel)<<"], most likely an invalid component id";
		}
	}
	else
	{
		LOG(Log::WRN) << " failed to set component [name:"<<m_loggingComponentName<<" id:"<<m_loggingComponentId<<"] to level ["<<v.toUtf8()<<"], unrecognized log level string (use on of {ERR|WRN|INF|DBG|TRC})";
	}

	return OpcUa_BadInvalidArgument;
}

}


/* © Copyright CERN, 2015.  All rights not expressly granted are reserved.
 * DGeneralLogLevel.cpp
 *
 *  Created on: Aug 18, 2015
 * 	Author: Benjamin Farnham <benjamin.farnham@cern.ch>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <Configuration.hxx>
#include <DGeneralLogLevel.h>
#include <ASGeneralLogLevel.h>
#include <LogIt.h>
#include <LogLevels.h>

namespace Device
{
DGeneralLogLevel::DGeneralLogLevel (const std::string& logLevel)
:Base_DGeneralLogLevel()
{
	writeLogLevel(logLevel.c_str());
}

DGeneralLogLevel::~DGeneralLogLevel ()
{}

UaStatus DGeneralLogLevel::writeLogLevel ( const UaString & v)
{
    Log::LOG_LEVEL targetLevel;

    if(logLevelFromString(v.toUtf8(), targetLevel))
    {
        LOG(Log::INF) << "setting log level to ["<<Log::logLevelToString(targetLevel)<<"]";
        Log::setNonComponentLogLevel(targetLevel);

        return OpcUa_Good;
    }
	else
	{
		LOG(Log::WRN) << " failed to set general log level to level ["<<v.toUtf8()<<"], unrecognized log level string (use on of {ERR|WRN|INF|DBG|TRC})";
	}


    return OpcUa_BadInvalidArgument;
}

}
/* © Copyright CERN, Universidad de Oviedo, 2015.  All rights not expressly granted are reserved.
 * DQuasar.cpp
 *
 *  Created on: Nov 5, 2015
 * 		Author: Damian Abalo Miron <damian.abalo@cern.ch>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <Configuration.hxx>

#include <DQuasar.h>
#include <ASQuasar.h>
#include "QuasarVersion.h"





namespace Device
{




// 1111111111111111111111111111111111111111111111111111111111111111111111111
// 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
// 1     Users don't modify this code!!!!                                  1
// 1     If you modify this code you may start a fire or a flood somewhere,1
// 1     and some human being may possible cease to exist. You don't want  1
// 1     to be charged with that!                                          1
// 1111111111111111111111111111111111111111111111111111111111111111111111111






// 2222222222222222222222222222222222222222222222222222222222222222222222222
// 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
// 2     (code for which only stubs were generated automatically)          2
// 2     You should add the implementation but dont alter the headers      2
// 2     (apart from constructor, in which you should complete initializati2
// 2     on list)                                                          2
// 2222222222222222222222222222222222222222222222222222222222222222222222222

/* sample ctr */
DQuasar::DQuasar (const Configuration::Quasar & config

                  , DRoot * parent

                 ):
    Base_DQuasar( config

                  , parent

                )
    /* fill up constructor initialization list here */
{
    /* fill up constructor body here */	
}

/* sample dtr */
DQuasar::~DQuasar ()
{
}

void DQuasar::updateVersion()
{
	getAddressSpaceLink()->setVersion(QUASAR_VERSION_STR, OpcUa_Good);
}
/* delegators for cachevariables and externalvariables */



// 3333333333333333333333333333333333333333333333333333333333333333333333333
// 3     FULLY CUSTOM CODE STARTS HERE                                     3
// 3     Below you put bodies for custom methods defined for this class.   3
// 3     You can do whatever you want, but please be decent.               3
// 3333333333333333333333333333333333333333333333333333333333333333333333333




}


/* © Copyright CERN, Universidad de Oviedo, 2015.  All rights not expressly granted are reserved.
 * DServer.cpp
 *
 *  Created on: Nov 5, 2015
 * 		Author: Damian Abalo Miron <damian.abalo@cern.ch>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <Configuration.hxx>

#include <DServer.h>
#include <ASServer.h>





namespace Device
{




// 1111111111111111111111111111111111111111111111111111111111111111111111111
// 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
// 1     Users don't modify this code!!!!                                  1
// 1     If you modify this code you may start a fire or a flood somewhere,1
// 1     and some human being may possible cease to exist. You don't want  1
// 1     to be charged with that!                                          1
// 1111111111111111111111111111111111111111111111111111111111111111111111111






// 2222222222222222222222222222222222222222222222222222222222222222222222222
// 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
// 2     (code for which only stubs were generated automatically)          2
// 2     You should add the implementation but dont alter the headers      2
// 2     (apart from constructor, in which you should complete initializati2
// 2     on list)                                                          2
// 2222222222222222222222222222222222222222222222222222222222222222222222222

/* sample ctr */
DServer::DServer (const Configuration::Server & config

                  , DRoot * parent

                 ):
    Base_DServer( config

                  , parent

                )
    /* fill up constructor initialization list here */
{
    /* fill up constructor body here */
}

/* sample dtr */
DServer::~DServer ()
{
}

/* delegators for cachevariables and externalvariables */



// 3333333333333333333333333333333333333333333333333333333333333333333333333
// 3     FULLY CUSTOM CODE STARTS HERE                                     3
// 3     Below you put bodies for custom methods defined for this class.   3
// 3     You can do whatever you want, but please be decent.               3
// 3333333333333333333333333333333333333333333333333333333333333333333333333

void DServer::updateRemainingCertificateValidity(const std::string& remainingValidity)
{
	getAddressSpaceLink()->setRemainingCertificateValidity(remainingValidity.c_str(), OpcUa_Good);
}


}


/* © Copyright CERN, 2015.  All rights not expressly granted are reserved.
 * DSourceVariableThreadPool.cpp
 *
 *  Created on: Aug 18, 2015
 * 	Author: Benjamin Farnham <benjamin.farnham@cern.ch>
 *      Author: Piotr Nikiel <piotr@nikiel.info>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <Configuration.hxx>

#include <DSourceVariableThreadPool.h>
#include <ASSourceVariableThreadPool.h>

#include <SourceVariables.h>



namespace Device
{




// 1111111111111111111111111111111111111111111111111111111111111111111111111
// 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
// 1     Users don't modify this code!!!!                                  1
// 1     If you modify this code you may start a fire or a flood somewhere,1
// 1     and some human being may possible cease to exist. You don't want  1
// 1     to be charged with that!                                          1
// 1111111111111111111111111111111111111111111111111111111111111111111111111






// 2222222222222222222222222222222222222222222222222222222222222222222222222
// 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
// 2     (code for which only stubs were generated automatically)          2
// 2     You should add the implementation but dont alter the headers      2
// 2     (apart from constructor, in which you should complete initializati2
// 2     on list)                                                          2
// 2222222222222222222222222222222222222222222222222222222222222222222222222

/* sample ctr */
DSourceVariableThreadPool::DSourceVariableThreadPool (const size_t& min, const size_t& max, const size_t& maxJobs)
:Base_DSourceVariableThreadPool()
{
  #ifndef BACKEND_OPEN62541
    AddressSpace::SourceVariables_initSourceVariablesThreadPool (min, max, maxJobs);
  #endif
}

/* sample dtr */
DSourceVariableThreadPool::~DSourceVariableThreadPool ()
{
}

/* delegators for cachevariables and externalvariables */



// 3333333333333333333333333333333333333333333333333333333333333333333333333
// 3     FULLY CUSTOM CODE STARTS HERE                                     3
// 3     Below you put bodies for custom methods defined for this class.   3
// 3     You can do whatever you want, but please be decent.               3
// 3333333333333333333333333333333333333333333333333333333333333333333333333




}


/* © Copyright CERN, 2015.  All rights not expressly granted are reserved.
 * DStandardMetaData.cpp
 *
 *  Created on: Aug 18, 2015
 * 	Author: Benjamin Farnham <benjamin.farnham@cern.ch>
 *      Author: Piotr Nikiel <piotr@nikiel.info>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <Configuration.hxx>

#include <DStandardMetaData.h>
#include <ASStandardMetaData.h>


namespace Device
{

// 1111111111111111111111111111111111111111111111111111111111111111111111111
// 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
// 1     Users don't modify this code!!!!                                  1
// 1     If you modify this code you may start a fire or a flood somewhere,1
// 1     and some human being may possible cease to exist. You don't want  1
// 1     to be charged with that!                                          1
// 1111111111111111111111111111111111111111111111111111111111111111111111111






// 2222222222222222222222222222222222222222222222222222222222222222222222222
// 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
// 2     (code for which only stubs were generated automatically)          2
// 2     You should add the implementation but dont alter the headers      2
// 2     (apart from constructor, in which you should complete initializati2
// 2     on list)                                                          2
// 2222222222222222222222222222222222222222222222222222222222222222222222222

/* sample ctr */
DStandardMetaData::DStandardMetaData (const Configuration::StandardMetaData & config, DRoot * parent)
:Base_DStandardMetaData( config, parent)
{}

/* sample dtr */
DStandardMetaData::~DStandardMetaData ()
{}
}


/* © Copyright CERN, Universidad de Oviedo, 2015.  All rights not expressly granted are reserved.
 * MetaUtils.h
 *
 *  Created on: Aug 18, 2015
 * 		Author: Benjamin Farnham <benjamin.farnham@cern.ch>
 *		Author: Damian Abalo Miron <damian.abalo@cern.ch>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */
#include "MetaUtils.h"
#include "Certificate.h"

using std::string;

Device::DServer* g_dServer = 0;

void MetaUtils::assertNodeAdded(const UaStatus& status, const UaNodeId& parentNodeId, const UaNodeId& childNodeId)
{
    if (!status.isGood())
    {
        std::cout << "While addNodeAndReference from " << parentNodeId.toString().toUtf8() << " to " << childNodeId.toString().toUtf8() << " : " << std::endl;
        ASSERT_GOOD(status);
    }
}


void MetaUtils::setDServer(Device::DServer* ser)
{
	g_dServer = ser;
}

string MetaUtils::calculateRemainingCertificateValidity(void)
{
    Certificate::Instance( Certificate::DEFAULT_PUBLIC_CERT_FILENAME, Certificate::DEFAULT_PRIVATE_CERT_FILENAME, Certificate::BEHAVIOR_TRY )->init();
    return Certificate::Instance()->remainingTime();
}



/* © Copyright CERN, 2015.  All rights not expressly granted are reserved.
 * meta.cpp
 *
 *  Created on: Aug 18, 2015
 * 	Author: Benjamin Farnham <benjamin.farnham@cern.ch>
 *      Author: Piotr Nikiel <piotr@nikiel.info>
 *
 *  This file is part of Quasar.
 *
 *  Quasar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public Licence as published by
 *  the Free Software Foundation, either version 3 of the Licence.
 *
 *  Quasar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public Licence for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <meta.h>
#include <sstream>
#include <iostream>
#include <list>

#include <LogIt.h>
#include <LogLevels.h>

#include <ASUtils.h>
#include <ASInformationModel.h>
#include <ASNodeManager.h>

#include <MetaUtils.h>

#include <ASStandardMetaData.h>
#include <DStandardMetaData.h>
#include <ASLog.h>
#include <DRoot.h>
#include <ASGeneralLogLevel.h>
#include <ASComponentLogLevel.h>
#include <DGeneralLogLevel.h>
#include <DComponentLogLevel.h>
#include <ASComponentLogLevels.h>
#include <ASSourceVariableThreadPool.h>
#include <DSourceVariableThreadPool.h>
#include <ASBuildInformation.h>
#include <DBuildInformation.h>
#include <ASQuasar.h>
#include <DQuasar.h>
#include <ASServer.h>
#include <DServer.h>
#include "MetaBuildInfo.h"

using std::string;

const string getComponentLogLevelFromConfig(const Log::LogComponentHandle& componentHandle, const Configuration::ComponentLogLevels& config)
{
	// find current level from LogIt (i.e. as default)
	Log::LOG_LEVEL level;
	if (!getComponentLogLevel(componentHandle, level))
	{
		LOG(Log::ERR) << "logging component handle ["<<componentHandle<<"] name ["<< Log::getComponentName(componentHandle) <<"] has no associated log level (returning [UNKNOWN!]): This should not happen - most likely a quasar programming error";
		return "UNKNOWN!";
	}
	string result = Log::logLevelToString(level);

	// find level in configuration
	for(const Configuration::ComponentLogLevel & componentLogLevelConfig : config.ComponentLogLevel())
	{
		const string configuredComponentName = componentLogLevelConfig.componentName();
		if(configuredComponentName == Log::getComponentName(componentHandle))
		{
			result = componentLogLevelConfig.logLevel();
		}
	}

	LOG(Log::INF) << "configuration for logging component  handle [" << componentHandle << "] name [" << Log::getComponentName(componentHandle) << "] using value ["<<result<<"]";
	return result;
}

/**
 * This function ensures that:
 * 1) all specified component log levels are registered in the server (to prevent config file typos, etc)
 * 2) that all specified component log levels are present at most once (to not have conflicting levels)
 * @throw std::runtime_error if the logging component level settings are not sane
 * @return void
 */
void validateComponentLogLevels( const Configuration::ComponentLogLevels& logLevels )
{
	std::list<std::string> checkedComponentNames;
	const std::map<Log::LogComponentHandle, std::string> registeredComponents = Log::getComponentLogsList();
	for( const Configuration::ComponentLogLevel &logLevel: logLevels.ComponentLogLevel() )
	{
		std::string name (logLevel.componentName());

		/* 1) validate the component is registered - query its id based on name */
		if (Log::getComponentHandle(name) == Log::INVALID_HANDLE)
		{
			std::ostringstream err;
			err << "Component Log Level name [" << name << "] is unknown (not registered).";
			std::cerr << err.str() << std::endl;
			throw std::runtime_error(err.str());
		}

		/* 2) check for duplicates */
		if (std::find(checkedComponentNames.begin(), checkedComponentNames.end(), name) != checkedComponentNames.end())
		{
			std::ostringstream err;
			err << "Component Log Level name [" << name << "] is given more than once.";
			std::cerr << err.str() << std::endl;
			throw std::runtime_error(err.str());
		}
		checkedComponentNames.push_back( name );
	}
}

const Configuration::ComponentLogLevels getComponentLogLevels(const Configuration::Log & config)
{
	if(config.ComponentLogLevels().present())
	{
		LOG(Log::INF) << "StandardMetaData.Log.ComponentLogLevels configuration found in the configuration file, configuring StandardMetaData.Log.ComponentLogLevels from the configuration file";
		return config.ComponentLogLevels().get();
	}
	else
	{
		LOG(Log::INF) << "no StandardMetaData.Log.ComponentLogLevels configuration found in the configuration file, configuring StandardMetaData.Log.ComponentLogLevels with default values";
		return Configuration::ComponentLogLevels();
	}
}

const string getGeneralLogLevelFromConfig(const Configuration::Log & config)
{
	// default to value used by logger.
	string result = Log::logLevelToString(Log::getNonComponentLogLevel());

	if( config.GeneralLogLevel().present() )
	{
		result = config.GeneralLogLevel().get().logLevel();
	}

	LOG(Log::INF) << "general non-component log level will be ["<<result<<"]";
	return result;
}

void configureGeneralLogLevel(const string& logLevel, AddressSpace::ASNodeManager *nm, AddressSpace::ASLog* parent)
{
    AddressSpace::ASGeneralLogLevel *asGeneralLogLevel = new AddressSpace::ASGeneralLogLevel(parent->nodeId(), nm->getTypeNodeId(AddressSpace::ASInformationModel::AS_TYPE_GENERALLOGLEVEL), nm, logLevel);

    Device::DGeneralLogLevel* dGeneralLogLevel = new Device::DGeneralLogLevel (logLevel);
    MetaUtils::linkHandlerObjectAndAddressSpaceNode(dGeneralLogLevel, asGeneralLogLevel);
}

void configureSourceVariableThreadPool(const Configuration::SourceVariableThreadPool& config, AddressSpace::ASNodeManager *nm,  AddressSpace::ASStandardMetaData* parent)
{
    AddressSpace::ASSourceVariableThreadPool *asSourceVariableThreadPool = new AddressSpace::ASSourceVariableThreadPool(parent->nodeId(), nm->getTypeNodeId(AddressSpace::ASInformationModel::AS_TYPE_SOURCEVARIABLESTHREADPOOL), nm, config.minThreads(), config.maxThreads());

    Device::DSourceVariableThreadPool* dSourceVariableThreadPool = new Device::DSourceVariableThreadPool(config.minThreads(), config.maxThreads(), config.maxJobs());
    MetaUtils::linkHandlerObjectAndAddressSpaceNode(dSourceVariableThreadPool, asSourceVariableThreadPool);
}

void configureBuildInformation(AddressSpace::ASNodeManager *nm,  AddressSpace::ASStandardMetaData* parent)
{
    const string buildHost(BuildMetaInfo::getBuildHost());
    const string buildTimestamp(BuildMetaInfo::getBuildTime());
    const string commitID(BuildMetaInfo::getCommitID());
    const string toolkitLibs(BuildMetaInfo::getToolkitLibs());

    AddressSpace::ASBuildInformation *asBuildInformation = new AddressSpace::ASBuildInformation(parent->nodeId(), nm->getTypeNodeId(AddressSpace::ASInformationModel::AS_TYPE_BUILDINFORMATION), nm,
			buildHost, buildTimestamp, commitID, toolkitLibs);
    Device::DBuildInformation* dBuildInformation = new Device::DBuildInformation(buildHost,
    		buildTimestamp, commitID, toolkitLibs);
    MetaUtils::linkHandlerObjectAndAddressSpaceNode(dBuildInformation, asBuildInformation);
}

void configureQuasar(const Configuration::Quasar& config, AddressSpace::ASNodeManager *nm,  AddressSpace::ASStandardMetaData* parent, Device::DRoot * deviceParent)
{
    AddressSpace::ASQuasar *asQuasar = new AddressSpace::ASQuasar(parent->nodeId(), nm->getTypeNodeId(AddressSpace::ASInformationModel::AS_TYPE_QUASAR), nm, config);

    Device::DQuasar* dQuasar = new Device::DQuasar(config, deviceParent);
    MetaUtils::linkHandlerObjectAndAddressSpaceNode(dQuasar, asQuasar);
    dQuasar->updateVersion();
}

void configureServer(const Configuration::Server& config, AddressSpace::ASNodeManager *nm,  AddressSpace::ASStandardMetaData* parent, Device::DRoot * deviceParent)
{
    AddressSpace::ASServer *asServer = new AddressSpace::ASServer(parent->nodeId(), nm->getTypeNodeId(AddressSpace::ASInformationModel::AS_TYPE_SERVER), nm, config);

    Device::DServer* dServer = new Device::DServer(config, deviceParent);
    MetaUtils::linkHandlerObjectAndAddressSpaceNode(dServer, asServer);
    MetaUtils::setDServer(dServer);

    //pnikiel: temporary disabled as per OPCUA-1564 due to planned work on OPCUA-1541
    //dServer->updateRemainingCertificateValidity(MetaUtils::calculateRemainingCertificateValidity());
}

void configureComponentLogLevel(const Log::LogComponentHandle& componentHandle, const string& logLevel, AddressSpace::ASNodeManager *nm, AddressSpace::ASComponentLogLevels* parent)
{
    AddressSpace::ASComponentLogLevel *asComponentLogLevel = new AddressSpace::ASComponentLogLevel(parent->nodeId(), nm->getTypeNodeId(AddressSpace::ASInformationModel::AS_TYPE_COMPONENTLOGLEVEL), nm, Log::getComponentName(componentHandle), logLevel);

    Device::DComponentLogLevel* dComponentLogLevel = new Device::DComponentLogLevel (componentHandle, logLevel);
    MetaUtils::linkHandlerObjectAndAddressSpaceNode(dComponentLogLevel, asComponentLogLevel);
}

const Configuration::Log getLogConfig(const Configuration::StandardMetaData & config)
{
	if( config.Log().present() )
	{
		LOG(Log::INF) << "StandardMetaData.Log configuration found in the configuration file, configuring StandardMetaData.Log from the configuration file";
		return config.Log().get();
	}
	else
	{
		LOG(Log::INF) << "no StandardMetaData.Log configuration found in the configuration file, configuring StandardMetaData.Log with default values";
		return Configuration::Log();
	}
}

const Configuration::SourceVariableThreadPool getSourceVariableThreadPoolConfig(const Configuration::StandardMetaData & config)
{
	if( config.SourceVariableThreadPool().present() )
	{
		LOG(Log::INF) << "StandardMetaData.SourceVariableThreadPool configuration found in the configuration file, configuring StandardMetaData.SourceVariableThreadPool from the configuration file";
		return config.SourceVariableThreadPool().get();
	}
	else
	{
		LOG(Log::INF) << "no StandardMetaData.SourceVariableThreadPool configuration found in the configuration file, configuring StandardMetaData.SourceVariableThreadPool with default values";
		return Configuration::SourceVariableThreadPool();
	}
}

const Configuration::Quasar getQuasarConfig(const Configuration::StandardMetaData & config)
{
	if( config.Quasar().present() )
	{
		LOG(Log::INF) << "StandardMetaData.Quasar configuration found in the configuration file, configuringStandardMetaData.Quasar from the configuration file";
		return config.Quasar().get();
	}
	else
	{
		LOG(Log::INF) << "no StandardMetaData.Quasar configuration found in the configuration file, configuring StandardMetaData.Quasar with default values";
		return Configuration::Quasar();
	}
}

const Configuration::Server getServerConfig(const Configuration::StandardMetaData & config)
{
	if( config.Server().present() )
	{
		LOG(Log::INF) << "StandardMetaData.Server configuration found in the configuration file, configuringStandardMetaData.Server from the configuration file";
		return config.Server().get();
	}
	else
	{
		LOG(Log::INF) << "no StandardMetaData.Server configuration found in the configuration file, configuring StandardMetaData.Server with default values";
		return Configuration::Server();
	}
}

void configureComponentLogLevels(const Configuration::ComponentLogLevels& config, AddressSpace::ASNodeManager* nm, AddressSpace::ASLog *parent)
{
    AddressSpace::ASComponentLogLevels* asComponentLogLevels = new AddressSpace::ASComponentLogLevels(parent->nodeId(), nm->getTypeNodeId(AddressSpace::ASInformationModel::AS_TYPE_COMPONENTLOGLEVELS), nm);

	for(const auto& componentMapEntry : Log::getComponentLogsList())
    {
		const Log::LogComponentHandle& componentHandle = componentMapEntry.first;
    	const string componentLogLevel = getComponentLogLevelFromConfig(componentHandle, config);
    	configureComponentLogLevel(componentHandle, componentLogLevel, nm, asComponentLogLevels);
    }
}

void configureLog(const Configuration::Log & config, AddressSpace::ASNodeManager *nm, AddressSpace::ASStandardMetaData* parent)
{
    AddressSpace::ASLog *asLog = new AddressSpace::ASLog(parent->nodeId(),nm->getTypeNodeId(AddressSpace::ASInformationModel::AS_TYPE_LOG), nm, config);

    configureGeneralLogLevel(getGeneralLogLevelFromConfig(config), nm, asLog);
    const Configuration::ComponentLogLevels componentLogLevels = getComponentLogLevels(config);
	validateComponentLogLevels(componentLogLevels);
    configureComponentLogLevels(componentLogLevels, nm, asLog);
}

const Configuration::StandardMetaData getMetaConfig(const Configuration::Configuration& config)
{
	if( config.StandardMetaData().present() )
	{
		LOG(Log::INF) << "meta configuration found in the configuration file, configuring StandardMetaData from the configuration file";
		return config.StandardMetaData().get();
	}
	else
	{
		LOG(Log::INF) << "no Meta configuration found in the configuration file, configuring StandardMetaData with default values";
		return Configuration::StandardMetaData ();
	}
}

Device::DStandardMetaData* configureMeta( const Configuration::StandardMetaData & config,AddressSpace::ASNodeManager *nm, UaNodeId parentNodeId, Device::DRoot * parent)
{
    AddressSpace::ASStandardMetaData *asMeta = new AddressSpace::ASStandardMetaData(parentNodeId, nm->getTypeNodeId(AddressSpace::ASInformationModel::AS_TYPE_STANDARDMETADATA), nm, config);
    UaStatus s = nm->addNodeAndReference( parentNodeId, asMeta, OpcUaId_HasComponent);
    MetaUtils::assertNodeAdded(s, parentNodeId, asMeta->nodeId());

    Device::DStandardMetaData *dMeta = new Device::DStandardMetaData (config, parent);
    MetaUtils::linkHandlerObjectAndAddressSpaceNode(dMeta, asMeta);

    configureLog(getLogConfig(config), nm, asMeta);
    configureSourceVariableThreadPool(getSourceVariableThreadPoolConfig(config), nm, asMeta);
    configureQuasar(getQuasarConfig(config), nm, asMeta, parent);
	configureServer(getServerConfig(config), nm, asMeta, parent);
	configureBuildInformation(nm, asMeta);
	
    return dMeta;
}

Device::DStandardMetaData* configureMeta(Configuration::Configuration & config, AddressSpace::ASNodeManager *nm, UaNodeId parentNodeId)
{
	return configureMeta(getMetaConfig(config), nm, parentNodeId, Device::DRoot::getInstance());
}

void destroyMeta (AddressSpace::ASNodeManager *nm)
{
	unlinkAllAddressSpaceItems<AddressSpace::ASStandardMetaData>(nm);
	unlinkAllAddressSpaceItems<AddressSpace::ASGeneralLogLevel>(nm);
	unlinkAllAddressSpaceItems<AddressSpace::ASComponentLogLevel>(nm);
	unlinkAllAddressSpaceItems<AddressSpace::ASQuasar>(nm);
	unlinkAllAddressSpaceItems<AddressSpace::ASServer>(nm);
	unlinkAllAddressSpaceItems<AddressSpace::ASSourceVariableThreadPool>(nm);
	unlinkAllAddressSpaceItems<AddressSpace::ASBuildInformation>(nm);
}
