// Copyright (c) 2005-2017 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX_HOME_ROOT_QUASAR_OPCUA_SERVER_BUILD_CONFIGURATION_CONFIGURATION_HXX
#define CXX_HOME_ROOT_QUASAR_OPCUA_SERVER_BUILD_CONFIGURATION_CONFIGURATION_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4009911L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace Configuration
{
  class StandardMetaData;
  class Log;
  class GeneralLogLevel;
  class ComponentLogLevels;
  class ComponentLogLevel;
  class SourceVariableThreadPool;
  class logLevelIdentifier;
  class Quasar;
  class Server;
  class ObjectName;
  class CalculatedVariable;
  class CalculatedVariableGenericFormula;
  class FreeVariable;
  class Regs;
  class Configuration;
  class type;
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move
#include <cstddef>   // std::size_t
#include <vector>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

namespace Configuration
{
  class StandardMetaData: public ::xml_schema::type
  {
    public:
    // Quasar
    //
    typedef ::Configuration::Quasar Quasar_type;
    typedef ::xsd::cxx::tree::optional< Quasar_type > Quasar_optional;
    typedef ::xsd::cxx::tree::traits< Quasar_type, char > Quasar_traits;

    static const ::std::size_t Quasar_id = 1UL;

    const Quasar_optional&
    Quasar () const;

    Quasar_optional&
    Quasar ();

    void
    Quasar (const Quasar_type& x);

    void
    Quasar (const Quasar_optional& x);

    void
    Quasar (::std::unique_ptr< Quasar_type > p);

    // Log
    //
    typedef ::Configuration::Log Log_type;
    typedef ::xsd::cxx::tree::optional< Log_type > Log_optional;
    typedef ::xsd::cxx::tree::traits< Log_type, char > Log_traits;

    static const ::std::size_t Log_id = 2UL;

    const Log_optional&
    Log () const;

    Log_optional&
    Log ();

    void
    Log (const Log_type& x);

    void
    Log (const Log_optional& x);

    void
    Log (::std::unique_ptr< Log_type > p);

    // SourceVariableThreadPool
    //
    typedef ::Configuration::SourceVariableThreadPool SourceVariableThreadPool_type;
    typedef ::xsd::cxx::tree::optional< SourceVariableThreadPool_type > SourceVariableThreadPool_optional;
    typedef ::xsd::cxx::tree::traits< SourceVariableThreadPool_type, char > SourceVariableThreadPool_traits;

    static const ::std::size_t SourceVariableThreadPool_id = 3UL;

    const SourceVariableThreadPool_optional&
    SourceVariableThreadPool () const;

    SourceVariableThreadPool_optional&
    SourceVariableThreadPool ();

    void
    SourceVariableThreadPool (const SourceVariableThreadPool_type& x);

    void
    SourceVariableThreadPool (const SourceVariableThreadPool_optional& x);

    void
    SourceVariableThreadPool (::std::unique_ptr< SourceVariableThreadPool_type > p);

    // Server
    //
    typedef ::Configuration::Server Server_type;
    typedef ::xsd::cxx::tree::optional< Server_type > Server_optional;
    typedef ::xsd::cxx::tree::traits< Server_type, char > Server_traits;

    static const ::std::size_t Server_id = 4UL;

    const Server_optional&
    Server () const;

    Server_optional&
    Server ();

    void
    Server (const Server_type& x);

    void
    Server (const Server_optional& x);

    void
    Server (::std::unique_ptr< Server_type > p);

    // content_order
    //
    typedef ::xml_schema::content_order content_order_type;
    typedef ::std::vector< content_order_type > content_order_sequence;
    typedef content_order_sequence::iterator content_order_iterator;
    typedef content_order_sequence::const_iterator content_order_const_iterator;

    const content_order_sequence&
    content_order () const;

    content_order_sequence&
    content_order ();

    void
    content_order (const content_order_sequence& s);

    // Constructors.
    //
    StandardMetaData ();

    StandardMetaData (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    StandardMetaData (const StandardMetaData& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual StandardMetaData*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    StandardMetaData&
    operator= (const StandardMetaData& x);

    virtual 
    ~StandardMetaData ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    content_order_sequence content_order_;

    Quasar_optional Quasar_;
    Log_optional Log_;
    SourceVariableThreadPool_optional SourceVariableThreadPool_;
    Server_optional Server_;
  };

  class Log: public ::xml_schema::type
  {
    public:
    // GeneralLogLevel
    //
    typedef ::Configuration::GeneralLogLevel GeneralLogLevel_type;
    typedef ::xsd::cxx::tree::optional< GeneralLogLevel_type > GeneralLogLevel_optional;
    typedef ::xsd::cxx::tree::traits< GeneralLogLevel_type, char > GeneralLogLevel_traits;

    static const ::std::size_t GeneralLogLevel_id = 1UL;

    const GeneralLogLevel_optional&
    GeneralLogLevel () const;

    GeneralLogLevel_optional&
    GeneralLogLevel ();

    void
    GeneralLogLevel (const GeneralLogLevel_type& x);

    void
    GeneralLogLevel (const GeneralLogLevel_optional& x);

    void
    GeneralLogLevel (::std::unique_ptr< GeneralLogLevel_type > p);

    // ComponentLogLevels
    //
    typedef ::Configuration::ComponentLogLevels ComponentLogLevels_type;
    typedef ::xsd::cxx::tree::optional< ComponentLogLevels_type > ComponentLogLevels_optional;
    typedef ::xsd::cxx::tree::traits< ComponentLogLevels_type, char > ComponentLogLevels_traits;

    static const ::std::size_t ComponentLogLevels_id = 2UL;

    const ComponentLogLevels_optional&
    ComponentLogLevels () const;

    ComponentLogLevels_optional&
    ComponentLogLevels ();

    void
    ComponentLogLevels (const ComponentLogLevels_type& x);

    void
    ComponentLogLevels (const ComponentLogLevels_optional& x);

    void
    ComponentLogLevels (::std::unique_ptr< ComponentLogLevels_type > p);

    // content_order
    //
    typedef ::xml_schema::content_order content_order_type;
    typedef ::std::vector< content_order_type > content_order_sequence;
    typedef content_order_sequence::iterator content_order_iterator;
    typedef content_order_sequence::const_iterator content_order_const_iterator;

    const content_order_sequence&
    content_order () const;

    content_order_sequence&
    content_order ();

    void
    content_order (const content_order_sequence& s);

    // Constructors.
    //
    Log ();

    Log (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

    Log (const Log& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

    virtual Log*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Log&
    operator= (const Log& x);

    virtual 
    ~Log ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    content_order_sequence content_order_;

    GeneralLogLevel_optional GeneralLogLevel_;
    ComponentLogLevels_optional ComponentLogLevels_;
  };

  class GeneralLogLevel: public ::xml_schema::type
  {
    public:
    // logLevel
    //
    typedef ::Configuration::logLevelIdentifier logLevel_type;
    typedef ::xsd::cxx::tree::traits< logLevel_type, char > logLevel_traits;

    const logLevel_type&
    logLevel () const;

    logLevel_type&
    logLevel ();

    void
    logLevel (const logLevel_type& x);

    void
    logLevel (::std::unique_ptr< logLevel_type > p);

    // content_order
    //
    typedef ::xml_schema::content_order content_order_type;
    typedef ::std::vector< content_order_type > content_order_sequence;
    typedef content_order_sequence::iterator content_order_iterator;
    typedef content_order_sequence::const_iterator content_order_const_iterator;

    const content_order_sequence&
    content_order () const;

    content_order_sequence&
    content_order ();

    void
    content_order (const content_order_sequence& s);

    // Constructors.
    //
    GeneralLogLevel (const logLevel_type&);

    GeneralLogLevel (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    GeneralLogLevel (const GeneralLogLevel& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual GeneralLogLevel*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    GeneralLogLevel&
    operator= (const GeneralLogLevel& x);

    virtual 
    ~GeneralLogLevel ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    content_order_sequence content_order_;

    ::xsd::cxx::tree::one< logLevel_type > logLevel_;
  };

  class ComponentLogLevels: public ::xml_schema::type
  {
    public:
    // ComponentLogLevel
    //
    typedef ::Configuration::ComponentLogLevel ComponentLogLevel_type;
    typedef ::xsd::cxx::tree::sequence< ComponentLogLevel_type > ComponentLogLevel_sequence;
    typedef ComponentLogLevel_sequence::iterator ComponentLogLevel_iterator;
    typedef ComponentLogLevel_sequence::const_iterator ComponentLogLevel_const_iterator;
    typedef ::xsd::cxx::tree::traits< ComponentLogLevel_type, char > ComponentLogLevel_traits;

    static const ::std::size_t ComponentLogLevel_id = 1UL;

    const ComponentLogLevel_sequence&
    ComponentLogLevel () const;

    ComponentLogLevel_sequence&
    ComponentLogLevel ();

    void
    ComponentLogLevel (const ComponentLogLevel_sequence& s);

    // content_order
    //
    typedef ::xml_schema::content_order content_order_type;
    typedef ::std::vector< content_order_type > content_order_sequence;
    typedef content_order_sequence::iterator content_order_iterator;
    typedef content_order_sequence::const_iterator content_order_const_iterator;

    const content_order_sequence&
    content_order () const;

    content_order_sequence&
    content_order ();

    void
    content_order (const content_order_sequence& s);

    // Constructors.
    //
    ComponentLogLevels ();

    ComponentLogLevels (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    ComponentLogLevels (const ComponentLogLevels& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual ComponentLogLevels*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ComponentLogLevels&
    operator= (const ComponentLogLevels& x);

    virtual 
    ~ComponentLogLevels ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    content_order_sequence content_order_;

    ComponentLogLevel_sequence ComponentLogLevel_;
  };

  class ComponentLogLevel: public ::xml_schema::type
  {
    public:
    // componentName
    //
    typedef ::xml_schema::string componentName_type;
    typedef ::xsd::cxx::tree::traits< componentName_type, char > componentName_traits;

    const componentName_type&
    componentName () const;

    componentName_type&
    componentName ();

    void
    componentName (const componentName_type& x);

    void
    componentName (::std::unique_ptr< componentName_type > p);

    // logLevel
    //
    typedef ::Configuration::logLevelIdentifier logLevel_type;
    typedef ::xsd::cxx::tree::traits< logLevel_type, char > logLevel_traits;

    const logLevel_type&
    logLevel () const;

    logLevel_type&
    logLevel ();

    void
    logLevel (const logLevel_type& x);

    void
    logLevel (::std::unique_ptr< logLevel_type > p);

    // content_order
    //
    typedef ::xml_schema::content_order content_order_type;
    typedef ::std::vector< content_order_type > content_order_sequence;
    typedef content_order_sequence::iterator content_order_iterator;
    typedef content_order_sequence::const_iterator content_order_const_iterator;

    const content_order_sequence&
    content_order () const;

    content_order_sequence&
    content_order ();

    void
    content_order (const content_order_sequence& s);

    // Constructors.
    //
    ComponentLogLevel (const componentName_type&,
                       const logLevel_type&);

    ComponentLogLevel (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    ComponentLogLevel (const ComponentLogLevel& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual ComponentLogLevel*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ComponentLogLevel&
    operator= (const ComponentLogLevel& x);

    virtual 
    ~ComponentLogLevel ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    content_order_sequence content_order_;

    ::xsd::cxx::tree::one< componentName_type > componentName_;
    ::xsd::cxx::tree::one< logLevel_type > logLevel_;
  };

  class SourceVariableThreadPool: public ::xml_schema::type
  {
    public:
    // minThreads
    //
    typedef ::xml_schema::unsigned_int minThreads_type;
    typedef ::xsd::cxx::tree::traits< minThreads_type, char > minThreads_traits;

    const minThreads_type&
    minThreads () const;

    minThreads_type&
    minThreads ();

    void
    minThreads (const minThreads_type& x);

    static minThreads_type
    minThreads_default_value ();

    // maxThreads
    //
    typedef ::xml_schema::unsigned_int maxThreads_type;
    typedef ::xsd::cxx::tree::traits< maxThreads_type, char > maxThreads_traits;

    const maxThreads_type&
    maxThreads () const;

    maxThreads_type&
    maxThreads ();

    void
    maxThreads (const maxThreads_type& x);

    static maxThreads_type
    maxThreads_default_value ();

    // maxJobs
    //
    typedef ::xml_schema::unsigned_int maxJobs_type;
    typedef ::xsd::cxx::tree::traits< maxJobs_type, char > maxJobs_traits;

    const maxJobs_type&
    maxJobs () const;

    maxJobs_type&
    maxJobs ();

    void
    maxJobs (const maxJobs_type& x);

    static maxJobs_type
    maxJobs_default_value ();

    // content_order
    //
    typedef ::xml_schema::content_order content_order_type;
    typedef ::std::vector< content_order_type > content_order_sequence;
    typedef content_order_sequence::iterator content_order_iterator;
    typedef content_order_sequence::const_iterator content_order_const_iterator;

    const content_order_sequence&
    content_order () const;

    content_order_sequence&
    content_order ();

    void
    content_order (const content_order_sequence& s);

    // Constructors.
    //
    SourceVariableThreadPool ();

    SourceVariableThreadPool (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    SourceVariableThreadPool (const SourceVariableThreadPool& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual SourceVariableThreadPool*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SourceVariableThreadPool&
    operator= (const SourceVariableThreadPool& x);

    virtual 
    ~SourceVariableThreadPool ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    content_order_sequence content_order_;

    ::xsd::cxx::tree::one< minThreads_type > minThreads_;
    ::xsd::cxx::tree::one< maxThreads_type > maxThreads_;
    ::xsd::cxx::tree::one< maxJobs_type > maxJobs_;
  };

  class logLevelIdentifier: public ::xml_schema::string
  {
    public:
    enum value
    {
      ERR,
      WRN,
      INF,
      DBG,
      TRC
    };

    logLevelIdentifier (value v);

    logLevelIdentifier (const char* v);

    logLevelIdentifier (const ::std::string& v);

    logLevelIdentifier (const ::xml_schema::string& v);

    logLevelIdentifier (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    logLevelIdentifier (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    logLevelIdentifier (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    logLevelIdentifier (const logLevelIdentifier& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual logLevelIdentifier*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    logLevelIdentifier&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_logLevelIdentifier_convert ();
    }

    protected:
    value
    _xsd_logLevelIdentifier_convert () const;

    public:
    static const char* const _xsd_logLevelIdentifier_literals_[5];
    static const value _xsd_logLevelIdentifier_indexes_[5];
  };

  class Quasar: public ::xml_schema::type
  {
    public:
    // content_order
    //
    typedef ::xml_schema::content_order content_order_type;
    typedef ::std::vector< content_order_type > content_order_sequence;
    typedef content_order_sequence::iterator content_order_iterator;
    typedef content_order_sequence::const_iterator content_order_const_iterator;

    const content_order_sequence&
    content_order () const;

    content_order_sequence&
    content_order ();

    void
    content_order (const content_order_sequence& s);

    // Constructors.
    //
    Quasar ();

    Quasar (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    Quasar (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    Quasar (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    Quasar (const Quasar& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual Quasar*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Quasar ();

    // Implementation.
    //
    protected:
    content_order_sequence content_order_;
  };

  class Server: public ::xml_schema::type
  {
    public:
    // content_order
    //
    typedef ::xml_schema::content_order content_order_type;
    typedef ::std::vector< content_order_type > content_order_sequence;
    typedef content_order_sequence::iterator content_order_iterator;
    typedef content_order_sequence::const_iterator content_order_const_iterator;

    const content_order_sequence&
    content_order () const;

    content_order_sequence&
    content_order ();

    void
    content_order (const content_order_sequence& s);

    // Constructors.
    //
    Server ();

    Server (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    Server (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    Server (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    Server (const Server& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual Server*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Server ();

    // Implementation.
    //
    protected:
    content_order_sequence content_order_;
  };

  class ObjectName: public ::xml_schema::string
  {
    public:
    // content_order
    //
    typedef ::xml_schema::content_order content_order_type;
    typedef ::std::vector< content_order_type > content_order_sequence;
    typedef content_order_sequence::iterator content_order_iterator;
    typedef content_order_sequence::const_iterator content_order_const_iterator;

    const content_order_sequence&
    content_order () const;

    content_order_sequence&
    content_order ();

    void
    content_order (const content_order_sequence& s);

    // Constructors.
    //
    ObjectName ();

    ObjectName (const char*);

    ObjectName (const ::std::string&);

    ObjectName (const ::xml_schema::string&);

    ObjectName (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    ObjectName (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    ObjectName (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    ObjectName (const ObjectName& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual ObjectName*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~ObjectName ();

    // Implementation.
    //
    protected:
    content_order_sequence content_order_;
  };

  class CalculatedVariable: public ::xml_schema::type
  {
    public:
    // name
    //
    typedef ::Configuration::ObjectName name_type;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_type&
    name () const;

    name_type&
    name ();

    void
    name (const name_type& x);

    void
    name (::std::unique_ptr< name_type > p);

    // value
    //
    typedef ::xml_schema::string value_type;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_type&
    value () const;

    value_type&
    value ();

    void
    value (const value_type& x);

    void
    value (::std::unique_ptr< value_type > p);

    // initialValue
    //
    typedef ::xml_schema::double_ initialValue_type;
    typedef ::xsd::cxx::tree::optional< initialValue_type > initialValue_optional;
    typedef ::xsd::cxx::tree::traits< initialValue_type, char, ::xsd::cxx::tree::schema_type::double_ > initialValue_traits;

    const initialValue_optional&
    initialValue () const;

    initialValue_optional&
    initialValue ();

    void
    initialValue (const initialValue_type& x);

    void
    initialValue (const initialValue_optional& x);

    // isBoolean
    //
    typedef ::xml_schema::boolean isBoolean_type;
    typedef ::xsd::cxx::tree::traits< isBoolean_type, char > isBoolean_traits;

    const isBoolean_type&
    isBoolean () const;

    isBoolean_type&
    isBoolean ();

    void
    isBoolean (const isBoolean_type& x);

    static isBoolean_type
    isBoolean_default_value ();

    // status
    //
    typedef ::xml_schema::string status_type;
    typedef ::xsd::cxx::tree::optional< status_type > status_optional;
    typedef ::xsd::cxx::tree::traits< status_type, char > status_traits;

    const status_optional&
    status () const;

    status_optional&
    status ();

    void
    status (const status_type& x);

    void
    status (const status_optional& x);

    void
    status (::std::unique_ptr< status_type > p);

    // content_order
    //
    typedef ::xml_schema::content_order content_order_type;
    typedef ::std::vector< content_order_type > content_order_sequence;
    typedef content_order_sequence::iterator content_order_iterator;
    typedef content_order_sequence::const_iterator content_order_const_iterator;

    const content_order_sequence&
    content_order () const;

    content_order_sequence&
    content_order ();

    void
    content_order (const content_order_sequence& s);

    // Constructors.
    //
    CalculatedVariable (const name_type&,
                        const value_type&);

    CalculatedVariable (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    CalculatedVariable (const CalculatedVariable& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual CalculatedVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CalculatedVariable&
    operator= (const CalculatedVariable& x);

    virtual 
    ~CalculatedVariable ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    content_order_sequence content_order_;

    ::xsd::cxx::tree::one< name_type > name_;
    ::xsd::cxx::tree::one< value_type > value_;
    initialValue_optional initialValue_;
    ::xsd::cxx::tree::one< isBoolean_type > isBoolean_;
    status_optional status_;
  };

  class CalculatedVariableGenericFormula: public ::xml_schema::type
  {
    public:
    // name
    //
    typedef ::Configuration::ObjectName name_type;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_type&
    name () const;

    name_type&
    name ();

    void
    name (const name_type& x);

    void
    name (::std::unique_ptr< name_type > p);

    // formula
    //
    typedef ::xml_schema::string formula_type;
    typedef ::xsd::cxx::tree::traits< formula_type, char > formula_traits;

    const formula_type&
    formula () const;

    formula_type&
    formula ();

    void
    formula (const formula_type& x);

    void
    formula (::std::unique_ptr< formula_type > p);

    // content_order
    //
    typedef ::xml_schema::content_order content_order_type;
    typedef ::std::vector< content_order_type > content_order_sequence;
    typedef content_order_sequence::iterator content_order_iterator;
    typedef content_order_sequence::const_iterator content_order_const_iterator;

    const content_order_sequence&
    content_order () const;

    content_order_sequence&
    content_order ();

    void
    content_order (const content_order_sequence& s);

    // Constructors.
    //
    CalculatedVariableGenericFormula (const name_type&,
                                      const formula_type&);

    CalculatedVariableGenericFormula (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    CalculatedVariableGenericFormula (const CalculatedVariableGenericFormula& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

    virtual CalculatedVariableGenericFormula*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    CalculatedVariableGenericFormula&
    operator= (const CalculatedVariableGenericFormula& x);

    virtual 
    ~CalculatedVariableGenericFormula ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    content_order_sequence content_order_;

    ::xsd::cxx::tree::one< name_type > name_;
    ::xsd::cxx::tree::one< formula_type > formula_;
  };

  class FreeVariable: public ::xml_schema::type
  {
    public:
    // name
    //
    typedef ::Configuration::ObjectName name_type;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_type&
    name () const;

    name_type&
    name ();

    void
    name (const name_type& x);

    void
    name (::std::unique_ptr< name_type > p);

    // type
    //
    typedef ::Configuration::type type_type;
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    const type_type&
    type () const;

    type_type&
    type ();

    void
    type (const type_type& x);

    void
    type (::std::unique_ptr< type_type > p);

    // initialValue
    //
    typedef ::xml_schema::string initialValue_type;
    typedef ::xsd::cxx::tree::optional< initialValue_type > initialValue_optional;
    typedef ::xsd::cxx::tree::traits< initialValue_type, char > initialValue_traits;

    const initialValue_optional&
    initialValue () const;

    initialValue_optional&
    initialValue ();

    void
    initialValue (const initialValue_type& x);

    void
    initialValue (const initialValue_optional& x);

    void
    initialValue (::std::unique_ptr< initialValue_type > p);

    // content_order
    //
    typedef ::xml_schema::content_order content_order_type;
    typedef ::std::vector< content_order_type > content_order_sequence;
    typedef content_order_sequence::iterator content_order_iterator;
    typedef content_order_sequence::const_iterator content_order_const_iterator;

    const content_order_sequence&
    content_order () const;

    content_order_sequence&
    content_order ();

    void
    content_order (const content_order_sequence& s);

    // Constructors.
    //
    FreeVariable (const name_type&,
                  const type_type&);

    FreeVariable (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    FreeVariable (const FreeVariable& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual FreeVariable*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FreeVariable&
    operator= (const FreeVariable& x);

    virtual 
    ~FreeVariable ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    content_order_sequence content_order_;

    ::xsd::cxx::tree::one< name_type > name_;
    ::xsd::cxx::tree::one< type_type > type_;
    initialValue_optional initialValue_;
  };

  class Regs: public ::xml_schema::type
  {
    public:
    // CalculatedVariable
    //
    typedef ::Configuration::CalculatedVariable CalculatedVariable_type;
    typedef ::xsd::cxx::tree::sequence< CalculatedVariable_type > CalculatedVariable_sequence;
    typedef CalculatedVariable_sequence::iterator CalculatedVariable_iterator;
    typedef CalculatedVariable_sequence::const_iterator CalculatedVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< CalculatedVariable_type, char > CalculatedVariable_traits;

    static const ::std::size_t CalculatedVariable_id = 1UL;

    const CalculatedVariable_sequence&
    CalculatedVariable () const;

    CalculatedVariable_sequence&
    CalculatedVariable ();

    void
    CalculatedVariable (const CalculatedVariable_sequence& s);

    // FreeVariable
    //
    typedef ::Configuration::FreeVariable FreeVariable_type;
    typedef ::xsd::cxx::tree::sequence< FreeVariable_type > FreeVariable_sequence;
    typedef FreeVariable_sequence::iterator FreeVariable_iterator;
    typedef FreeVariable_sequence::const_iterator FreeVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< FreeVariable_type, char > FreeVariable_traits;

    static const ::std::size_t FreeVariable_id = 2UL;

    const FreeVariable_sequence&
    FreeVariable () const;

    FreeVariable_sequence&
    FreeVariable ();

    void
    FreeVariable (const FreeVariable_sequence& s);

    // name
    //
    typedef ::Configuration::ObjectName name_type;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_type&
    name () const;

    name_type&
    name ();

    void
    name (const name_type& x);

    void
    name (::std::unique_ptr< name_type > p);

    // address
    //
    typedef ::xml_schema::unsigned_int address_type;
    typedef ::xsd::cxx::tree::traits< address_type, char > address_traits;

    const address_type&
    address () const;

    address_type&
    address ();

    void
    address (const address_type& x);

    // content_order
    //
    typedef ::xml_schema::content_order content_order_type;
    typedef ::std::vector< content_order_type > content_order_sequence;
    typedef content_order_sequence::iterator content_order_iterator;
    typedef content_order_sequence::const_iterator content_order_const_iterator;

    const content_order_sequence&
    content_order () const;

    content_order_sequence&
    content_order ();

    void
    content_order (const content_order_sequence& s);

    // Constructors.
    //
    Regs (const name_type&,
          const address_type&);

    Regs (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    Regs (const Regs& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual Regs*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Regs&
    operator= (const Regs& x);

    virtual 
    ~Regs ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    content_order_sequence content_order_;

    CalculatedVariable_sequence CalculatedVariable_;
    FreeVariable_sequence FreeVariable_;
    ::xsd::cxx::tree::one< name_type > name_;
    ::xsd::cxx::tree::one< address_type > address_;
  };

  class Configuration: public ::xml_schema::type
  {
    public:
    // StandardMetaData
    //
    typedef ::Configuration::StandardMetaData StandardMetaData_type;
    typedef ::xsd::cxx::tree::optional< StandardMetaData_type > StandardMetaData_optional;
    typedef ::xsd::cxx::tree::traits< StandardMetaData_type, char > StandardMetaData_traits;

    static const ::std::size_t StandardMetaData_id = 1UL;

    const StandardMetaData_optional&
    StandardMetaData () const;

    StandardMetaData_optional&
    StandardMetaData ();

    void
    StandardMetaData (const StandardMetaData_type& x);

    void
    StandardMetaData (const StandardMetaData_optional& x);

    void
    StandardMetaData (::std::unique_ptr< StandardMetaData_type > p);

    // CalculatedVariableGenericFormula
    //
    typedef ::Configuration::CalculatedVariableGenericFormula CalculatedVariableGenericFormula_type;
    typedef ::xsd::cxx::tree::sequence< CalculatedVariableGenericFormula_type > CalculatedVariableGenericFormula_sequence;
    typedef CalculatedVariableGenericFormula_sequence::iterator CalculatedVariableGenericFormula_iterator;
    typedef CalculatedVariableGenericFormula_sequence::const_iterator CalculatedVariableGenericFormula_const_iterator;
    typedef ::xsd::cxx::tree::traits< CalculatedVariableGenericFormula_type, char > CalculatedVariableGenericFormula_traits;

    static const ::std::size_t CalculatedVariableGenericFormula_id = 2UL;

    const CalculatedVariableGenericFormula_sequence&
    CalculatedVariableGenericFormula () const;

    CalculatedVariableGenericFormula_sequence&
    CalculatedVariableGenericFormula ();

    void
    CalculatedVariableGenericFormula (const CalculatedVariableGenericFormula_sequence& s);

    // Regs
    //
    typedef ::Configuration::Regs Regs_type;
    typedef ::xsd::cxx::tree::sequence< Regs_type > Regs_sequence;
    typedef Regs_sequence::iterator Regs_iterator;
    typedef Regs_sequence::const_iterator Regs_const_iterator;
    typedef ::xsd::cxx::tree::traits< Regs_type, char > Regs_traits;

    static const ::std::size_t Regs_id = 3UL;

    const Regs_sequence&
    Regs () const;

    Regs_sequence&
    Regs ();

    void
    Regs (const Regs_sequence& s);

    // CalculatedVariable
    //
    typedef ::Configuration::CalculatedVariable CalculatedVariable_type;
    typedef ::xsd::cxx::tree::sequence< CalculatedVariable_type > CalculatedVariable_sequence;
    typedef CalculatedVariable_sequence::iterator CalculatedVariable_iterator;
    typedef CalculatedVariable_sequence::const_iterator CalculatedVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< CalculatedVariable_type, char > CalculatedVariable_traits;

    static const ::std::size_t CalculatedVariable_id = 4UL;

    const CalculatedVariable_sequence&
    CalculatedVariable () const;

    CalculatedVariable_sequence&
    CalculatedVariable ();

    void
    CalculatedVariable (const CalculatedVariable_sequence& s);

    // FreeVariable
    //
    typedef ::Configuration::FreeVariable FreeVariable_type;
    typedef ::xsd::cxx::tree::sequence< FreeVariable_type > FreeVariable_sequence;
    typedef FreeVariable_sequence::iterator FreeVariable_iterator;
    typedef FreeVariable_sequence::const_iterator FreeVariable_const_iterator;
    typedef ::xsd::cxx::tree::traits< FreeVariable_type, char > FreeVariable_traits;

    static const ::std::size_t FreeVariable_id = 5UL;

    const FreeVariable_sequence&
    FreeVariable () const;

    FreeVariable_sequence&
    FreeVariable ();

    void
    FreeVariable (const FreeVariable_sequence& s);

    // content_order
    //
    typedef ::xml_schema::content_order content_order_type;
    typedef ::std::vector< content_order_type > content_order_sequence;
    typedef content_order_sequence::iterator content_order_iterator;
    typedef content_order_sequence::const_iterator content_order_const_iterator;

    const content_order_sequence&
    content_order () const;

    content_order_sequence&
    content_order ();

    void
    content_order (const content_order_sequence& s);

    // Constructors.
    //
    Configuration ();

    Configuration (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    Configuration (const Configuration& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual Configuration*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Configuration&
    operator= (const Configuration& x);

    virtual 
    ~Configuration ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    content_order_sequence content_order_;

    StandardMetaData_optional StandardMetaData_;
    CalculatedVariableGenericFormula_sequence CalculatedVariableGenericFormula_;
    Regs_sequence Regs_;
    CalculatedVariable_sequence CalculatedVariable_;
    FreeVariable_sequence FreeVariable_;
  };

  class type: public ::xml_schema::string
  {
    public:
    enum value
    {
      Boolean,
      Byte,
      SByte,
      UInt16,
      Int16,
      UInt32,
      Int32,
      UInt64,
      Int64,
      Double,
      Float,
      String
    };

    type (value v);

    type (const char* v);

    type (const ::std::string& v);

    type (const ::xml_schema::string& v);

    type (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    type (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    type (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    type (const type& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual type*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    type&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_type_convert ();
    }

    protected:
    value
    _xsd_type_convert () const;

    public:
    static const char* const _xsd_type_literals_[12];
    static const value _xsd_type_indexes_[12];
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace Configuration
{
  // Parse a URI or a local file.
  //

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (const ::std::string& uri,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (const ::std::string& uri,
                 ::xml_schema::error_handler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (const ::std::string& uri,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse std::istream.
  //

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::std::istream& is,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::std::istream& is,
                 ::xml_schema::error_handler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::std::istream& is,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::std::istream& is,
                 const ::std::string& id,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::std::istream& is,
                 const ::std::string& id,
                 ::xml_schema::error_handler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::std::istream& is,
                 const ::std::string& id,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::InputSource.
  //

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::xercesc::InputSource& is,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::xercesc::InputSource& is,
                 ::xml_schema::error_handler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::xercesc::InputSource& is,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace Configuration
{
  void
  operator<< (::xercesc::DOMElement&, const StandardMetaData&);

  void
  operator<< (::xercesc::DOMElement&, const Log&);

  void
  operator<< (::xercesc::DOMElement&, const GeneralLogLevel&);

  void
  operator<< (::xercesc::DOMElement&, const ComponentLogLevels&);

  void
  operator<< (::xercesc::DOMElement&, const ComponentLogLevel&);

  void
  operator<< (::xercesc::DOMElement&, const SourceVariableThreadPool&);

  void
  operator<< (::xercesc::DOMElement&, const logLevelIdentifier&);

  void
  operator<< (::xercesc::DOMAttr&, const logLevelIdentifier&);

  void
  operator<< (::xml_schema::list_stream&,
              const logLevelIdentifier&);

  void
  operator<< (::xercesc::DOMElement&, const Quasar&);

  void
  operator<< (::xercesc::DOMAttr&, const Quasar&);

  void
  operator<< (::xml_schema::list_stream&,
              const Quasar&);

  void
  operator<< (::xercesc::DOMElement&, const Server&);

  void
  operator<< (::xercesc::DOMAttr&, const Server&);

  void
  operator<< (::xml_schema::list_stream&,
              const Server&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectName&);

  void
  operator<< (::xercesc::DOMAttr&, const ObjectName&);

  void
  operator<< (::xml_schema::list_stream&,
              const ObjectName&);

  void
  operator<< (::xercesc::DOMElement&, const CalculatedVariable&);

  void
  operator<< (::xercesc::DOMElement&, const CalculatedVariableGenericFormula&);

  void
  operator<< (::xercesc::DOMElement&, const FreeVariable&);

  void
  operator<< (::xercesc::DOMElement&, const Regs&);

  void
  operator<< (::xercesc::DOMElement&, const Configuration&);

  // Serialize to std::ostream.
  //

  void
  configuration (::std::ostream& os,
                 const ::Configuration::Configuration& x, 
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

  void
  configuration (::std::ostream& os,
                 const ::Configuration::Configuration& x, 
                 ::xml_schema::error_handler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

  void
  configuration (::std::ostream& os,
                 const ::Configuration::Configuration& x, 
                 ::xercesc::DOMErrorHandler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  configuration (::xercesc::XMLFormatTarget& ft,
                 const ::Configuration::Configuration& x, 
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

  void
  configuration (::xercesc::XMLFormatTarget& ft,
                 const ::Configuration::Configuration& x, 
                 ::xml_schema::error_handler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

  void
  configuration (::xercesc::XMLFormatTarget& ft,
                 const ::Configuration::Configuration& x, 
                 ::xercesc::DOMErrorHandler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  configuration (::xercesc::DOMDocument& d,
                 const ::Configuration::Configuration& x,
                 ::xml_schema::flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  configuration (const ::Configuration::Configuration& x, 
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 ::xml_schema::flags f = 0);

  void
  operator<< (::xercesc::DOMElement&, const type&);

  void
  operator<< (::xercesc::DOMAttr&, const type&);

  void
  operator<< (::xml_schema::list_stream&,
              const type&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX_HOME_ROOT_QUASAR_OPCUA_SERVER_BUILD_CONFIGURATION_CONFIGURATION_HXX
