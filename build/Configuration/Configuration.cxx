// Copyright (c) 2005-2017 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Configuration.hxx"

namespace Configuration
{
  // StandardMetaData
  // 

  const StandardMetaData::Quasar_optional& StandardMetaData::
  Quasar () const
  {
    return this->Quasar_;
  }

  StandardMetaData::Quasar_optional& StandardMetaData::
  Quasar ()
  {
    return this->Quasar_;
  }

  void StandardMetaData::
  Quasar (const Quasar_type& x)
  {
    this->Quasar_.set (x);
  }

  void StandardMetaData::
  Quasar (const Quasar_optional& x)
  {
    this->Quasar_ = x;
  }

  void StandardMetaData::
  Quasar (::std::unique_ptr< Quasar_type > x)
  {
    this->Quasar_.set (std::move (x));
  }

  const StandardMetaData::Log_optional& StandardMetaData::
  Log () const
  {
    return this->Log_;
  }

  StandardMetaData::Log_optional& StandardMetaData::
  Log ()
  {
    return this->Log_;
  }

  void StandardMetaData::
  Log (const Log_type& x)
  {
    this->Log_.set (x);
  }

  void StandardMetaData::
  Log (const Log_optional& x)
  {
    this->Log_ = x;
  }

  void StandardMetaData::
  Log (::std::unique_ptr< Log_type > x)
  {
    this->Log_.set (std::move (x));
  }

  const StandardMetaData::SourceVariableThreadPool_optional& StandardMetaData::
  SourceVariableThreadPool () const
  {
    return this->SourceVariableThreadPool_;
  }

  StandardMetaData::SourceVariableThreadPool_optional& StandardMetaData::
  SourceVariableThreadPool ()
  {
    return this->SourceVariableThreadPool_;
  }

  void StandardMetaData::
  SourceVariableThreadPool (const SourceVariableThreadPool_type& x)
  {
    this->SourceVariableThreadPool_.set (x);
  }

  void StandardMetaData::
  SourceVariableThreadPool (const SourceVariableThreadPool_optional& x)
  {
    this->SourceVariableThreadPool_ = x;
  }

  void StandardMetaData::
  SourceVariableThreadPool (::std::unique_ptr< SourceVariableThreadPool_type > x)
  {
    this->SourceVariableThreadPool_.set (std::move (x));
  }

  const StandardMetaData::Server_optional& StandardMetaData::
  Server () const
  {
    return this->Server_;
  }

  StandardMetaData::Server_optional& StandardMetaData::
  Server ()
  {
    return this->Server_;
  }

  void StandardMetaData::
  Server (const Server_type& x)
  {
    this->Server_.set (x);
  }

  void StandardMetaData::
  Server (const Server_optional& x)
  {
    this->Server_ = x;
  }

  void StandardMetaData::
  Server (::std::unique_ptr< Server_type > x)
  {
    this->Server_.set (std::move (x));
  }

  const StandardMetaData::content_order_sequence& StandardMetaData::
  content_order () const
  {
    return this->content_order_;
  }

  StandardMetaData::content_order_sequence& StandardMetaData::
  content_order ()
  {
    return this->content_order_;
  }

  void StandardMetaData::
  content_order (const content_order_sequence& s)
  {
    this->content_order_ = s;
  }


  // Log
  // 

  const Log::GeneralLogLevel_optional& Log::
  GeneralLogLevel () const
  {
    return this->GeneralLogLevel_;
  }

  Log::GeneralLogLevel_optional& Log::
  GeneralLogLevel ()
  {
    return this->GeneralLogLevel_;
  }

  void Log::
  GeneralLogLevel (const GeneralLogLevel_type& x)
  {
    this->GeneralLogLevel_.set (x);
  }

  void Log::
  GeneralLogLevel (const GeneralLogLevel_optional& x)
  {
    this->GeneralLogLevel_ = x;
  }

  void Log::
  GeneralLogLevel (::std::unique_ptr< GeneralLogLevel_type > x)
  {
    this->GeneralLogLevel_.set (std::move (x));
  }

  const Log::ComponentLogLevels_optional& Log::
  ComponentLogLevels () const
  {
    return this->ComponentLogLevels_;
  }

  Log::ComponentLogLevels_optional& Log::
  ComponentLogLevels ()
  {
    return this->ComponentLogLevels_;
  }

  void Log::
  ComponentLogLevels (const ComponentLogLevels_type& x)
  {
    this->ComponentLogLevels_.set (x);
  }

  void Log::
  ComponentLogLevels (const ComponentLogLevels_optional& x)
  {
    this->ComponentLogLevels_ = x;
  }

  void Log::
  ComponentLogLevels (::std::unique_ptr< ComponentLogLevels_type > x)
  {
    this->ComponentLogLevels_.set (std::move (x));
  }

  const Log::content_order_sequence& Log::
  content_order () const
  {
    return this->content_order_;
  }

  Log::content_order_sequence& Log::
  content_order ()
  {
    return this->content_order_;
  }

  void Log::
  content_order (const content_order_sequence& s)
  {
    this->content_order_ = s;
  }


  // GeneralLogLevel
  // 

  const GeneralLogLevel::logLevel_type& GeneralLogLevel::
  logLevel () const
  {
    return this->logLevel_.get ();
  }

  GeneralLogLevel::logLevel_type& GeneralLogLevel::
  logLevel ()
  {
    return this->logLevel_.get ();
  }

  void GeneralLogLevel::
  logLevel (const logLevel_type& x)
  {
    this->logLevel_.set (x);
  }

  void GeneralLogLevel::
  logLevel (::std::unique_ptr< logLevel_type > x)
  {
    this->logLevel_.set (std::move (x));
  }

  const GeneralLogLevel::content_order_sequence& GeneralLogLevel::
  content_order () const
  {
    return this->content_order_;
  }

  GeneralLogLevel::content_order_sequence& GeneralLogLevel::
  content_order ()
  {
    return this->content_order_;
  }

  void GeneralLogLevel::
  content_order (const content_order_sequence& s)
  {
    this->content_order_ = s;
  }


  // ComponentLogLevels
  // 

  const ComponentLogLevels::ComponentLogLevel_sequence& ComponentLogLevels::
  ComponentLogLevel () const
  {
    return this->ComponentLogLevel_;
  }

  ComponentLogLevels::ComponentLogLevel_sequence& ComponentLogLevels::
  ComponentLogLevel ()
  {
    return this->ComponentLogLevel_;
  }

  void ComponentLogLevels::
  ComponentLogLevel (const ComponentLogLevel_sequence& s)
  {
    this->ComponentLogLevel_ = s;
  }

  const ComponentLogLevels::content_order_sequence& ComponentLogLevels::
  content_order () const
  {
    return this->content_order_;
  }

  ComponentLogLevels::content_order_sequence& ComponentLogLevels::
  content_order ()
  {
    return this->content_order_;
  }

  void ComponentLogLevels::
  content_order (const content_order_sequence& s)
  {
    this->content_order_ = s;
  }


  // ComponentLogLevel
  // 

  const ComponentLogLevel::componentName_type& ComponentLogLevel::
  componentName () const
  {
    return this->componentName_.get ();
  }

  ComponentLogLevel::componentName_type& ComponentLogLevel::
  componentName ()
  {
    return this->componentName_.get ();
  }

  void ComponentLogLevel::
  componentName (const componentName_type& x)
  {
    this->componentName_.set (x);
  }

  void ComponentLogLevel::
  componentName (::std::unique_ptr< componentName_type > x)
  {
    this->componentName_.set (std::move (x));
  }

  const ComponentLogLevel::logLevel_type& ComponentLogLevel::
  logLevel () const
  {
    return this->logLevel_.get ();
  }

  ComponentLogLevel::logLevel_type& ComponentLogLevel::
  logLevel ()
  {
    return this->logLevel_.get ();
  }

  void ComponentLogLevel::
  logLevel (const logLevel_type& x)
  {
    this->logLevel_.set (x);
  }

  void ComponentLogLevel::
  logLevel (::std::unique_ptr< logLevel_type > x)
  {
    this->logLevel_.set (std::move (x));
  }

  const ComponentLogLevel::content_order_sequence& ComponentLogLevel::
  content_order () const
  {
    return this->content_order_;
  }

  ComponentLogLevel::content_order_sequence& ComponentLogLevel::
  content_order ()
  {
    return this->content_order_;
  }

  void ComponentLogLevel::
  content_order (const content_order_sequence& s)
  {
    this->content_order_ = s;
  }


  // SourceVariableThreadPool
  // 

  const SourceVariableThreadPool::minThreads_type& SourceVariableThreadPool::
  minThreads () const
  {
    return this->minThreads_.get ();
  }

  SourceVariableThreadPool::minThreads_type& SourceVariableThreadPool::
  minThreads ()
  {
    return this->minThreads_.get ();
  }

  void SourceVariableThreadPool::
  minThreads (const minThreads_type& x)
  {
    this->minThreads_.set (x);
  }

  SourceVariableThreadPool::minThreads_type SourceVariableThreadPool::
  minThreads_default_value ()
  {
    return minThreads_type (1U);
  }

  const SourceVariableThreadPool::maxThreads_type& SourceVariableThreadPool::
  maxThreads () const
  {
    return this->maxThreads_.get ();
  }

  SourceVariableThreadPool::maxThreads_type& SourceVariableThreadPool::
  maxThreads ()
  {
    return this->maxThreads_.get ();
  }

  void SourceVariableThreadPool::
  maxThreads (const maxThreads_type& x)
  {
    this->maxThreads_.set (x);
  }

  SourceVariableThreadPool::maxThreads_type SourceVariableThreadPool::
  maxThreads_default_value ()
  {
    return maxThreads_type (10U);
  }

  const SourceVariableThreadPool::maxJobs_type& SourceVariableThreadPool::
  maxJobs () const
  {
    return this->maxJobs_.get ();
  }

  SourceVariableThreadPool::maxJobs_type& SourceVariableThreadPool::
  maxJobs ()
  {
    return this->maxJobs_.get ();
  }

  void SourceVariableThreadPool::
  maxJobs (const maxJobs_type& x)
  {
    this->maxJobs_.set (x);
  }

  SourceVariableThreadPool::maxJobs_type SourceVariableThreadPool::
  maxJobs_default_value ()
  {
    return maxJobs_type (1000U);
  }

  const SourceVariableThreadPool::content_order_sequence& SourceVariableThreadPool::
  content_order () const
  {
    return this->content_order_;
  }

  SourceVariableThreadPool::content_order_sequence& SourceVariableThreadPool::
  content_order ()
  {
    return this->content_order_;
  }

  void SourceVariableThreadPool::
  content_order (const content_order_sequence& s)
  {
    this->content_order_ = s;
  }


  // logLevelIdentifier
  // 

  logLevelIdentifier::
  logLevelIdentifier (value v)
  : ::xml_schema::string (_xsd_logLevelIdentifier_literals_[v])
  {
  }

  logLevelIdentifier::
  logLevelIdentifier (const char* v)
  : ::xml_schema::string (v)
  {
  }

  logLevelIdentifier::
  logLevelIdentifier (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  logLevelIdentifier::
  logLevelIdentifier (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  logLevelIdentifier::
  logLevelIdentifier (const logLevelIdentifier& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  logLevelIdentifier& logLevelIdentifier::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_logLevelIdentifier_literals_[v]);

    return *this;
  }


  // Quasar
  // 

  const Quasar::content_order_sequence& Quasar::
  content_order () const
  {
    return this->content_order_;
  }

  Quasar::content_order_sequence& Quasar::
  content_order ()
  {
    return this->content_order_;
  }

  void Quasar::
  content_order (const content_order_sequence& s)
  {
    this->content_order_ = s;
  }


  // Server
  // 

  const Server::content_order_sequence& Server::
  content_order () const
  {
    return this->content_order_;
  }

  Server::content_order_sequence& Server::
  content_order ()
  {
    return this->content_order_;
  }

  void Server::
  content_order (const content_order_sequence& s)
  {
    this->content_order_ = s;
  }


  // ObjectName
  // 

  const ObjectName::content_order_sequence& ObjectName::
  content_order () const
  {
    return this->content_order_;
  }

  ObjectName::content_order_sequence& ObjectName::
  content_order ()
  {
    return this->content_order_;
  }

  void ObjectName::
  content_order (const content_order_sequence& s)
  {
    this->content_order_ = s;
  }


  // CalculatedVariable
  // 

  const CalculatedVariable::name_type& CalculatedVariable::
  name () const
  {
    return this->name_.get ();
  }

  CalculatedVariable::name_type& CalculatedVariable::
  name ()
  {
    return this->name_.get ();
  }

  void CalculatedVariable::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void CalculatedVariable::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const CalculatedVariable::value_type& CalculatedVariable::
  value () const
  {
    return this->value_.get ();
  }

  CalculatedVariable::value_type& CalculatedVariable::
  value ()
  {
    return this->value_.get ();
  }

  void CalculatedVariable::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void CalculatedVariable::
  value (::std::unique_ptr< value_type > x)
  {
    this->value_.set (std::move (x));
  }

  const CalculatedVariable::initialValue_optional& CalculatedVariable::
  initialValue () const
  {
    return this->initialValue_;
  }

  CalculatedVariable::initialValue_optional& CalculatedVariable::
  initialValue ()
  {
    return this->initialValue_;
  }

  void CalculatedVariable::
  initialValue (const initialValue_type& x)
  {
    this->initialValue_.set (x);
  }

  void CalculatedVariable::
  initialValue (const initialValue_optional& x)
  {
    this->initialValue_ = x;
  }

  const CalculatedVariable::isBoolean_type& CalculatedVariable::
  isBoolean () const
  {
    return this->isBoolean_.get ();
  }

  CalculatedVariable::isBoolean_type& CalculatedVariable::
  isBoolean ()
  {
    return this->isBoolean_.get ();
  }

  void CalculatedVariable::
  isBoolean (const isBoolean_type& x)
  {
    this->isBoolean_.set (x);
  }

  CalculatedVariable::isBoolean_type CalculatedVariable::
  isBoolean_default_value ()
  {
    return isBoolean_type (false);
  }

  const CalculatedVariable::status_optional& CalculatedVariable::
  status () const
  {
    return this->status_;
  }

  CalculatedVariable::status_optional& CalculatedVariable::
  status ()
  {
    return this->status_;
  }

  void CalculatedVariable::
  status (const status_type& x)
  {
    this->status_.set (x);
  }

  void CalculatedVariable::
  status (const status_optional& x)
  {
    this->status_ = x;
  }

  void CalculatedVariable::
  status (::std::unique_ptr< status_type > x)
  {
    this->status_.set (std::move (x));
  }

  const CalculatedVariable::content_order_sequence& CalculatedVariable::
  content_order () const
  {
    return this->content_order_;
  }

  CalculatedVariable::content_order_sequence& CalculatedVariable::
  content_order ()
  {
    return this->content_order_;
  }

  void CalculatedVariable::
  content_order (const content_order_sequence& s)
  {
    this->content_order_ = s;
  }


  // CalculatedVariableGenericFormula
  // 

  const CalculatedVariableGenericFormula::name_type& CalculatedVariableGenericFormula::
  name () const
  {
    return this->name_.get ();
  }

  CalculatedVariableGenericFormula::name_type& CalculatedVariableGenericFormula::
  name ()
  {
    return this->name_.get ();
  }

  void CalculatedVariableGenericFormula::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void CalculatedVariableGenericFormula::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const CalculatedVariableGenericFormula::formula_type& CalculatedVariableGenericFormula::
  formula () const
  {
    return this->formula_.get ();
  }

  CalculatedVariableGenericFormula::formula_type& CalculatedVariableGenericFormula::
  formula ()
  {
    return this->formula_.get ();
  }

  void CalculatedVariableGenericFormula::
  formula (const formula_type& x)
  {
    this->formula_.set (x);
  }

  void CalculatedVariableGenericFormula::
  formula (::std::unique_ptr< formula_type > x)
  {
    this->formula_.set (std::move (x));
  }

  const CalculatedVariableGenericFormula::content_order_sequence& CalculatedVariableGenericFormula::
  content_order () const
  {
    return this->content_order_;
  }

  CalculatedVariableGenericFormula::content_order_sequence& CalculatedVariableGenericFormula::
  content_order ()
  {
    return this->content_order_;
  }

  void CalculatedVariableGenericFormula::
  content_order (const content_order_sequence& s)
  {
    this->content_order_ = s;
  }


  // FreeVariable
  // 

  const FreeVariable::name_type& FreeVariable::
  name () const
  {
    return this->name_.get ();
  }

  FreeVariable::name_type& FreeVariable::
  name ()
  {
    return this->name_.get ();
  }

  void FreeVariable::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void FreeVariable::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const FreeVariable::type_type& FreeVariable::
  type () const
  {
    return this->type_.get ();
  }

  FreeVariable::type_type& FreeVariable::
  type ()
  {
    return this->type_.get ();
  }

  void FreeVariable::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void FreeVariable::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const FreeVariable::initialValue_optional& FreeVariable::
  initialValue () const
  {
    return this->initialValue_;
  }

  FreeVariable::initialValue_optional& FreeVariable::
  initialValue ()
  {
    return this->initialValue_;
  }

  void FreeVariable::
  initialValue (const initialValue_type& x)
  {
    this->initialValue_.set (x);
  }

  void FreeVariable::
  initialValue (const initialValue_optional& x)
  {
    this->initialValue_ = x;
  }

  void FreeVariable::
  initialValue (::std::unique_ptr< initialValue_type > x)
  {
    this->initialValue_.set (std::move (x));
  }

  const FreeVariable::content_order_sequence& FreeVariable::
  content_order () const
  {
    return this->content_order_;
  }

  FreeVariable::content_order_sequence& FreeVariable::
  content_order ()
  {
    return this->content_order_;
  }

  void FreeVariable::
  content_order (const content_order_sequence& s)
  {
    this->content_order_ = s;
  }


  // Regs
  // 

  const Regs::CalculatedVariable_sequence& Regs::
  CalculatedVariable () const
  {
    return this->CalculatedVariable_;
  }

  Regs::CalculatedVariable_sequence& Regs::
  CalculatedVariable ()
  {
    return this->CalculatedVariable_;
  }

  void Regs::
  CalculatedVariable (const CalculatedVariable_sequence& s)
  {
    this->CalculatedVariable_ = s;
  }

  const Regs::FreeVariable_sequence& Regs::
  FreeVariable () const
  {
    return this->FreeVariable_;
  }

  Regs::FreeVariable_sequence& Regs::
  FreeVariable ()
  {
    return this->FreeVariable_;
  }

  void Regs::
  FreeVariable (const FreeVariable_sequence& s)
  {
    this->FreeVariable_ = s;
  }

  const Regs::name_type& Regs::
  name () const
  {
    return this->name_.get ();
  }

  Regs::name_type& Regs::
  name ()
  {
    return this->name_.get ();
  }

  void Regs::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void Regs::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const Regs::address_type& Regs::
  address () const
  {
    return this->address_.get ();
  }

  Regs::address_type& Regs::
  address ()
  {
    return this->address_.get ();
  }

  void Regs::
  address (const address_type& x)
  {
    this->address_.set (x);
  }

  const Regs::content_order_sequence& Regs::
  content_order () const
  {
    return this->content_order_;
  }

  Regs::content_order_sequence& Regs::
  content_order ()
  {
    return this->content_order_;
  }

  void Regs::
  content_order (const content_order_sequence& s)
  {
    this->content_order_ = s;
  }


  // Configuration
  // 

  const Configuration::StandardMetaData_optional& Configuration::
  StandardMetaData () const
  {
    return this->StandardMetaData_;
  }

  Configuration::StandardMetaData_optional& Configuration::
  StandardMetaData ()
  {
    return this->StandardMetaData_;
  }

  void Configuration::
  StandardMetaData (const StandardMetaData_type& x)
  {
    this->StandardMetaData_.set (x);
  }

  void Configuration::
  StandardMetaData (const StandardMetaData_optional& x)
  {
    this->StandardMetaData_ = x;
  }

  void Configuration::
  StandardMetaData (::std::unique_ptr< StandardMetaData_type > x)
  {
    this->StandardMetaData_.set (std::move (x));
  }

  const Configuration::CalculatedVariableGenericFormula_sequence& Configuration::
  CalculatedVariableGenericFormula () const
  {
    return this->CalculatedVariableGenericFormula_;
  }

  Configuration::CalculatedVariableGenericFormula_sequence& Configuration::
  CalculatedVariableGenericFormula ()
  {
    return this->CalculatedVariableGenericFormula_;
  }

  void Configuration::
  CalculatedVariableGenericFormula (const CalculatedVariableGenericFormula_sequence& s)
  {
    this->CalculatedVariableGenericFormula_ = s;
  }

  const Configuration::Regs_sequence& Configuration::
  Regs () const
  {
    return this->Regs_;
  }

  Configuration::Regs_sequence& Configuration::
  Regs ()
  {
    return this->Regs_;
  }

  void Configuration::
  Regs (const Regs_sequence& s)
  {
    this->Regs_ = s;
  }

  const Configuration::CalculatedVariable_sequence& Configuration::
  CalculatedVariable () const
  {
    return this->CalculatedVariable_;
  }

  Configuration::CalculatedVariable_sequence& Configuration::
  CalculatedVariable ()
  {
    return this->CalculatedVariable_;
  }

  void Configuration::
  CalculatedVariable (const CalculatedVariable_sequence& s)
  {
    this->CalculatedVariable_ = s;
  }

  const Configuration::FreeVariable_sequence& Configuration::
  FreeVariable () const
  {
    return this->FreeVariable_;
  }

  Configuration::FreeVariable_sequence& Configuration::
  FreeVariable ()
  {
    return this->FreeVariable_;
  }

  void Configuration::
  FreeVariable (const FreeVariable_sequence& s)
  {
    this->FreeVariable_ = s;
  }

  const Configuration::content_order_sequence& Configuration::
  content_order () const
  {
    return this->content_order_;
  }

  Configuration::content_order_sequence& Configuration::
  content_order ()
  {
    return this->content_order_;
  }

  void Configuration::
  content_order (const content_order_sequence& s)
  {
    this->content_order_ = s;
  }


  // type
  // 

  type::
  type (value v)
  : ::xml_schema::string (_xsd_type_literals_[v])
  {
  }

  type::
  type (const char* v)
  : ::xml_schema::string (v)
  {
  }

  type::
  type (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  type::
  type (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  type::
  type (const type& v,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  type& type::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_type_literals_[v]);

    return *this;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace Configuration
{
  // StandardMetaData
  //

  StandardMetaData::
  StandardMetaData ()
  : ::xml_schema::type (),
    Quasar_ (this),
    Log_ (this),
    SourceVariableThreadPool_ (this),
    Server_ (this)
  {
  }

  StandardMetaData::
  StandardMetaData (const StandardMetaData& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    content_order_ (x.content_order_),
    Quasar_ (x.Quasar_, f, this),
    Log_ (x.Log_, f, this),
    SourceVariableThreadPool_ (x.SourceVariableThreadPool_, f, this),
    Server_ (x.Server_, f, this)
  {
  }

  StandardMetaData::
  StandardMetaData (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Quasar_ (this),
    Log_ (this),
    SourceVariableThreadPool_ (this),
    Server_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void StandardMetaData::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Quasar
      //
      if (n.name () == "Quasar" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< Quasar_type > r (
          Quasar_traits::create (i, f, this));

        if (!this->Quasar_)
        {
          this->Quasar_.set (::std::move (r));
          this->content_order_.push_back (
            content_order_type (Quasar_id));
          continue;
        }
      }

      // Log
      //
      if (n.name () == "Log" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< Log_type > r (
          Log_traits::create (i, f, this));

        if (!this->Log_)
        {
          this->Log_.set (::std::move (r));
          this->content_order_.push_back (
            content_order_type (Log_id));
          continue;
        }
      }

      // SourceVariableThreadPool
      //
      if (n.name () == "SourceVariableThreadPool" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< SourceVariableThreadPool_type > r (
          SourceVariableThreadPool_traits::create (i, f, this));

        if (!this->SourceVariableThreadPool_)
        {
          this->SourceVariableThreadPool_.set (::std::move (r));
          this->content_order_.push_back (
            content_order_type (SourceVariableThreadPool_id));
          continue;
        }
      }

      // Server
      //
      if (n.name () == "Server" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< Server_type > r (
          Server_traits::create (i, f, this));

        if (!this->Server_)
        {
          this->Server_.set (::std::move (r));
          this->content_order_.push_back (
            content_order_type (Server_id));
          continue;
        }
      }

      break;
    }
  }

  StandardMetaData* StandardMetaData::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class StandardMetaData (*this, f, c);
  }

  StandardMetaData& StandardMetaData::
  operator= (const StandardMetaData& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->content_order_ = x.content_order_;
      this->Quasar_ = x.Quasar_;
      this->Log_ = x.Log_;
      this->SourceVariableThreadPool_ = x.SourceVariableThreadPool_;
      this->Server_ = x.Server_;
    }

    return *this;
  }

  StandardMetaData::
  ~StandardMetaData ()
  {
  }

  // Log
  //

  Log::
  Log ()
  : ::xml_schema::type (),
    GeneralLogLevel_ (this),
    ComponentLogLevels_ (this)
  {
  }

  Log::
  Log (const Log& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    content_order_ (x.content_order_),
    GeneralLogLevel_ (x.GeneralLogLevel_, f, this),
    ComponentLogLevels_ (x.ComponentLogLevels_, f, this)
  {
  }

  Log::
  Log (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    GeneralLogLevel_ (this),
    ComponentLogLevels_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Log::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // GeneralLogLevel
      //
      if (n.name () == "GeneralLogLevel" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< GeneralLogLevel_type > r (
          GeneralLogLevel_traits::create (i, f, this));

        if (!this->GeneralLogLevel_)
        {
          this->GeneralLogLevel_.set (::std::move (r));
          this->content_order_.push_back (
            content_order_type (GeneralLogLevel_id));
          continue;
        }
      }

      // ComponentLogLevels
      //
      if (n.name () == "ComponentLogLevels" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< ComponentLogLevels_type > r (
          ComponentLogLevels_traits::create (i, f, this));

        if (!this->ComponentLogLevels_)
        {
          this->ComponentLogLevels_.set (::std::move (r));
          this->content_order_.push_back (
            content_order_type (ComponentLogLevels_id));
          continue;
        }
      }

      break;
    }
  }

  Log* Log::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Log (*this, f, c);
  }

  Log& Log::
  operator= (const Log& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->content_order_ = x.content_order_;
      this->GeneralLogLevel_ = x.GeneralLogLevel_;
      this->ComponentLogLevels_ = x.ComponentLogLevels_;
    }

    return *this;
  }

  Log::
  ~Log ()
  {
  }

  // GeneralLogLevel
  //

  GeneralLogLevel::
  GeneralLogLevel (const logLevel_type& logLevel)
  : ::xml_schema::type (),
    logLevel_ (logLevel, this)
  {
  }

  GeneralLogLevel::
  GeneralLogLevel (const GeneralLogLevel& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    content_order_ (x.content_order_),
    logLevel_ (x.logLevel_, f, this)
  {
  }

  GeneralLogLevel::
  GeneralLogLevel (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    logLevel_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void GeneralLogLevel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "logLevel" && n.namespace_ ().empty ())
      {
        this->logLevel_.set (logLevel_traits::create (i, f, this));
        continue;
      }
    }

    if (!logLevel_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "logLevel",
        "");
    }
  }

  GeneralLogLevel* GeneralLogLevel::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class GeneralLogLevel (*this, f, c);
  }

  GeneralLogLevel& GeneralLogLevel::
  operator= (const GeneralLogLevel& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->content_order_ = x.content_order_;
      this->logLevel_ = x.logLevel_;
    }

    return *this;
  }

  GeneralLogLevel::
  ~GeneralLogLevel ()
  {
  }

  // ComponentLogLevels
  //

  ComponentLogLevels::
  ComponentLogLevels ()
  : ::xml_schema::type (),
    ComponentLogLevel_ (this)
  {
  }

  ComponentLogLevels::
  ComponentLogLevels (const ComponentLogLevels& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    content_order_ (x.content_order_),
    ComponentLogLevel_ (x.ComponentLogLevel_, f, this)
  {
  }

  ComponentLogLevels::
  ComponentLogLevels (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ComponentLogLevel_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ComponentLogLevels::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ComponentLogLevel
      //
      if (n.name () == "ComponentLogLevel" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< ComponentLogLevel_type > r (
          ComponentLogLevel_traits::create (i, f, this));

        this->ComponentLogLevel_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (ComponentLogLevel_id, this->ComponentLogLevel_.size () - 1));
        continue;
      }

      break;
    }
  }

  ComponentLogLevels* ComponentLogLevels::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ComponentLogLevels (*this, f, c);
  }

  ComponentLogLevels& ComponentLogLevels::
  operator= (const ComponentLogLevels& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->content_order_ = x.content_order_;
      this->ComponentLogLevel_ = x.ComponentLogLevel_;
    }

    return *this;
  }

  ComponentLogLevels::
  ~ComponentLogLevels ()
  {
  }

  // ComponentLogLevel
  //

  ComponentLogLevel::
  ComponentLogLevel (const componentName_type& componentName,
                     const logLevel_type& logLevel)
  : ::xml_schema::type (),
    componentName_ (componentName, this),
    logLevel_ (logLevel, this)
  {
  }

  ComponentLogLevel::
  ComponentLogLevel (const ComponentLogLevel& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    content_order_ (x.content_order_),
    componentName_ (x.componentName_, f, this),
    logLevel_ (x.logLevel_, f, this)
  {
  }

  ComponentLogLevel::
  ComponentLogLevel (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    componentName_ (this),
    logLevel_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ComponentLogLevel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "componentName" && n.namespace_ ().empty ())
      {
        this->componentName_.set (componentName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "logLevel" && n.namespace_ ().empty ())
      {
        this->logLevel_.set (logLevel_traits::create (i, f, this));
        continue;
      }
    }

    if (!componentName_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "componentName",
        "");
    }

    if (!logLevel_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "logLevel",
        "");
    }
  }

  ComponentLogLevel* ComponentLogLevel::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ComponentLogLevel (*this, f, c);
  }

  ComponentLogLevel& ComponentLogLevel::
  operator= (const ComponentLogLevel& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->content_order_ = x.content_order_;
      this->componentName_ = x.componentName_;
      this->logLevel_ = x.logLevel_;
    }

    return *this;
  }

  ComponentLogLevel::
  ~ComponentLogLevel ()
  {
  }

  // SourceVariableThreadPool
  //

  SourceVariableThreadPool::
  SourceVariableThreadPool ()
  : ::xml_schema::type (),
    minThreads_ (minThreads_default_value (), this),
    maxThreads_ (maxThreads_default_value (), this),
    maxJobs_ (maxJobs_default_value (), this)
  {
  }

  SourceVariableThreadPool::
  SourceVariableThreadPool (const SourceVariableThreadPool& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    content_order_ (x.content_order_),
    minThreads_ (x.minThreads_, f, this),
    maxThreads_ (x.maxThreads_, f, this),
    maxJobs_ (x.maxJobs_, f, this)
  {
  }

  SourceVariableThreadPool::
  SourceVariableThreadPool (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    minThreads_ (this),
    maxThreads_ (this),
    maxJobs_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void SourceVariableThreadPool::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "minThreads" && n.namespace_ ().empty ())
      {
        this->minThreads_.set (minThreads_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxThreads" && n.namespace_ ().empty ())
      {
        this->maxThreads_.set (maxThreads_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxJobs" && n.namespace_ ().empty ())
      {
        this->maxJobs_.set (maxJobs_traits::create (i, f, this));
        continue;
      }
    }

    if (!minThreads_.present ())
    {
      this->minThreads_.set (minThreads_default_value ());
    }

    if (!maxThreads_.present ())
    {
      this->maxThreads_.set (maxThreads_default_value ());
    }

    if (!maxJobs_.present ())
    {
      this->maxJobs_.set (maxJobs_default_value ());
    }
  }

  SourceVariableThreadPool* SourceVariableThreadPool::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SourceVariableThreadPool (*this, f, c);
  }

  SourceVariableThreadPool& SourceVariableThreadPool::
  operator= (const SourceVariableThreadPool& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->content_order_ = x.content_order_;
      this->minThreads_ = x.minThreads_;
      this->maxThreads_ = x.maxThreads_;
      this->maxJobs_ = x.maxJobs_;
    }

    return *this;
  }

  SourceVariableThreadPool::
  ~SourceVariableThreadPool ()
  {
  }

  // logLevelIdentifier
  //

  logLevelIdentifier::
  logLevelIdentifier (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_logLevelIdentifier_convert ();
  }

  logLevelIdentifier::
  logLevelIdentifier (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_logLevelIdentifier_convert ();
  }

  logLevelIdentifier::
  logLevelIdentifier (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_logLevelIdentifier_convert ();
  }

  logLevelIdentifier* logLevelIdentifier::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class logLevelIdentifier (*this, f, c);
  }

  logLevelIdentifier::value logLevelIdentifier::
  _xsd_logLevelIdentifier_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_logLevelIdentifier_literals_);
    const value* i (::std::lower_bound (
                      _xsd_logLevelIdentifier_indexes_,
                      _xsd_logLevelIdentifier_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_logLevelIdentifier_indexes_ + 5 || _xsd_logLevelIdentifier_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const logLevelIdentifier::
  _xsd_logLevelIdentifier_literals_[5] =
  {
    "ERR",
    "WRN",
    "INF",
    "DBG",
    "TRC"
  };

  const logLevelIdentifier::value logLevelIdentifier::
  _xsd_logLevelIdentifier_indexes_[5] =
  {
    ::Configuration::logLevelIdentifier::DBG,
    ::Configuration::logLevelIdentifier::ERR,
    ::Configuration::logLevelIdentifier::INF,
    ::Configuration::logLevelIdentifier::TRC,
    ::Configuration::logLevelIdentifier::WRN
  };

  // Quasar
  //

  Quasar::
  Quasar ()
  : ::xml_schema::type ()
  {
  }

  Quasar::
  Quasar (const Quasar& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    content_order_ (x.content_order_)
  {
  }

  Quasar::
  Quasar (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  Quasar::
  Quasar (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  Quasar::
  Quasar (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  Quasar* Quasar::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Quasar (*this, f, c);
  }

  Quasar::
  ~Quasar ()
  {
  }

  // Server
  //

  Server::
  Server ()
  : ::xml_schema::type ()
  {
  }

  Server::
  Server (const Server& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    content_order_ (x.content_order_)
  {
  }

  Server::
  Server (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  Server::
  Server (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  Server::
  Server (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  Server* Server::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Server (*this, f, c);
  }

  Server::
  ~Server ()
  {
  }

  // ObjectName
  //

  ObjectName::
  ObjectName ()
  : ::xml_schema::string ()
  {
  }

  ObjectName::
  ObjectName (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  ObjectName::
  ObjectName (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  ObjectName::
  ObjectName (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  ObjectName::
  ObjectName (const ObjectName& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    content_order_ (x.content_order_)
  {
  }

  ObjectName::
  ObjectName (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  ObjectName::
  ObjectName (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  ObjectName::
  ObjectName (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  ObjectName* ObjectName::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ObjectName (*this, f, c);
  }

  ObjectName::
  ~ObjectName ()
  {
  }

  // CalculatedVariable
  //

  CalculatedVariable::
  CalculatedVariable (const name_type& name,
                      const value_type& value)
  : ::xml_schema::type (),
    name_ (name, this),
    value_ (value, this),
    initialValue_ (this),
    isBoolean_ (isBoolean_default_value (), this),
    status_ (this)
  {
  }

  CalculatedVariable::
  CalculatedVariable (const CalculatedVariable& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    content_order_ (x.content_order_),
    name_ (x.name_, f, this),
    value_ (x.value_, f, this),
    initialValue_ (x.initialValue_, f, this),
    isBoolean_ (x.isBoolean_, f, this),
    status_ (x.status_, f, this)
  {
  }

  CalculatedVariable::
  CalculatedVariable (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    value_ (this),
    initialValue_ (this),
    isBoolean_ (this),
    status_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CalculatedVariable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "initialValue" && n.namespace_ ().empty ())
      {
        this->initialValue_.set (initialValue_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isBoolean" && n.namespace_ ().empty ())
      {
        this->isBoolean_.set (isBoolean_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "status" && n.namespace_ ().empty ())
      {
        this->status_.set (status_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }

    if (!isBoolean_.present ())
    {
      this->isBoolean_.set (isBoolean_default_value ());
    }
  }

  CalculatedVariable* CalculatedVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CalculatedVariable (*this, f, c);
  }

  CalculatedVariable& CalculatedVariable::
  operator= (const CalculatedVariable& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->content_order_ = x.content_order_;
      this->name_ = x.name_;
      this->value_ = x.value_;
      this->initialValue_ = x.initialValue_;
      this->isBoolean_ = x.isBoolean_;
      this->status_ = x.status_;
    }

    return *this;
  }

  CalculatedVariable::
  ~CalculatedVariable ()
  {
  }

  // CalculatedVariableGenericFormula
  //

  CalculatedVariableGenericFormula::
  CalculatedVariableGenericFormula (const name_type& name,
                                    const formula_type& formula)
  : ::xml_schema::type (),
    name_ (name, this),
    formula_ (formula, this)
  {
  }

  CalculatedVariableGenericFormula::
  CalculatedVariableGenericFormula (const CalculatedVariableGenericFormula& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    content_order_ (x.content_order_),
    name_ (x.name_, f, this),
    formula_ (x.formula_, f, this)
  {
  }

  CalculatedVariableGenericFormula::
  CalculatedVariableGenericFormula (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    formula_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CalculatedVariableGenericFormula::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "formula" && n.namespace_ ().empty ())
      {
        this->formula_.set (formula_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!formula_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "formula",
        "");
    }
  }

  CalculatedVariableGenericFormula* CalculatedVariableGenericFormula::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CalculatedVariableGenericFormula (*this, f, c);
  }

  CalculatedVariableGenericFormula& CalculatedVariableGenericFormula::
  operator= (const CalculatedVariableGenericFormula& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->content_order_ = x.content_order_;
      this->name_ = x.name_;
      this->formula_ = x.formula_;
    }

    return *this;
  }

  CalculatedVariableGenericFormula::
  ~CalculatedVariableGenericFormula ()
  {
  }

  // FreeVariable
  //

  FreeVariable::
  FreeVariable (const name_type& name,
                const type_type& type)
  : ::xml_schema::type (),
    name_ (name, this),
    type_ (type, this),
    initialValue_ (this)
  {
  }

  FreeVariable::
  FreeVariable (const FreeVariable& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    content_order_ (x.content_order_),
    name_ (x.name_, f, this),
    type_ (x.type_, f, this),
    initialValue_ (x.initialValue_, f, this)
  {
  }

  FreeVariable::
  FreeVariable (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    type_ (this),
    initialValue_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void FreeVariable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "initialValue" && n.namespace_ ().empty ())
      {
        this->initialValue_.set (initialValue_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  FreeVariable* FreeVariable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FreeVariable (*this, f, c);
  }

  FreeVariable& FreeVariable::
  operator= (const FreeVariable& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->content_order_ = x.content_order_;
      this->name_ = x.name_;
      this->type_ = x.type_;
      this->initialValue_ = x.initialValue_;
    }

    return *this;
  }

  FreeVariable::
  ~FreeVariable ()
  {
  }

  // Regs
  //

  Regs::
  Regs (const name_type& name,
        const address_type& address)
  : ::xml_schema::type (),
    CalculatedVariable_ (this),
    FreeVariable_ (this),
    name_ (name, this),
    address_ (address, this)
  {
  }

  Regs::
  Regs (const Regs& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    content_order_ (x.content_order_),
    CalculatedVariable_ (x.CalculatedVariable_, f, this),
    FreeVariable_ (x.FreeVariable_, f, this),
    name_ (x.name_, f, this),
    address_ (x.address_, f, this)
  {
  }

  Regs::
  Regs (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CalculatedVariable_ (this),
    FreeVariable_ (this),
    name_ (this),
    address_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Regs::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CalculatedVariable
      //
      if (n.name () == "CalculatedVariable" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< CalculatedVariable_type > r (
          CalculatedVariable_traits::create (i, f, this));

        this->CalculatedVariable_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (CalculatedVariable_id, this->CalculatedVariable_.size () - 1));
        continue;
      }

      // FreeVariable
      //
      if (n.name () == "FreeVariable" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< FreeVariable_type > r (
          FreeVariable_traits::create (i, f, this));

        this->FreeVariable_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (FreeVariable_id, this->FreeVariable_.size () - 1));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "address" && n.namespace_ ().empty ())
      {
        this->address_.set (address_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!address_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "address",
        "");
    }
  }

  Regs* Regs::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Regs (*this, f, c);
  }

  Regs& Regs::
  operator= (const Regs& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->content_order_ = x.content_order_;
      this->CalculatedVariable_ = x.CalculatedVariable_;
      this->FreeVariable_ = x.FreeVariable_;
      this->name_ = x.name_;
      this->address_ = x.address_;
    }

    return *this;
  }

  Regs::
  ~Regs ()
  {
  }

  // Configuration
  //

  Configuration::
  Configuration ()
  : ::xml_schema::type (),
    StandardMetaData_ (this),
    CalculatedVariableGenericFormula_ (this),
    Regs_ (this),
    CalculatedVariable_ (this),
    FreeVariable_ (this)
  {
  }

  Configuration::
  Configuration (const Configuration& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    content_order_ (x.content_order_),
    StandardMetaData_ (x.StandardMetaData_, f, this),
    CalculatedVariableGenericFormula_ (x.CalculatedVariableGenericFormula_, f, this),
    Regs_ (x.Regs_, f, this),
    CalculatedVariable_ (x.CalculatedVariable_, f, this),
    FreeVariable_ (x.FreeVariable_, f, this)
  {
  }

  Configuration::
  Configuration (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    StandardMetaData_ (this),
    CalculatedVariableGenericFormula_ (this),
    Regs_ (this),
    CalculatedVariable_ (this),
    FreeVariable_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Configuration::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // StandardMetaData
      //
      if (n.name () == "StandardMetaData" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< StandardMetaData_type > r (
          StandardMetaData_traits::create (i, f, this));

        if (!this->StandardMetaData_)
        {
          this->StandardMetaData_.set (::std::move (r));
          this->content_order_.push_back (
            content_order_type (StandardMetaData_id));
          continue;
        }
      }

      // CalculatedVariableGenericFormula
      //
      if (n.name () == "CalculatedVariableGenericFormula" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< CalculatedVariableGenericFormula_type > r (
          CalculatedVariableGenericFormula_traits::create (i, f, this));

        this->CalculatedVariableGenericFormula_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (CalculatedVariableGenericFormula_id, this->CalculatedVariableGenericFormula_.size () - 1));
        continue;
      }

      // Regs
      //
      if (n.name () == "Regs" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< Regs_type > r (
          Regs_traits::create (i, f, this));

        this->Regs_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (Regs_id, this->Regs_.size () - 1));
        continue;
      }

      // CalculatedVariable
      //
      if (n.name () == "CalculatedVariable" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< CalculatedVariable_type > r (
          CalculatedVariable_traits::create (i, f, this));

        this->CalculatedVariable_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (CalculatedVariable_id, this->CalculatedVariable_.size () - 1));
        continue;
      }

      // FreeVariable
      //
      if (n.name () == "FreeVariable" && n.namespace_ () == "http://cern.ch/quasar/Configuration")
      {
        ::std::unique_ptr< FreeVariable_type > r (
          FreeVariable_traits::create (i, f, this));

        this->FreeVariable_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (FreeVariable_id, this->FreeVariable_.size () - 1));
        continue;
      }

      break;
    }
  }

  Configuration* Configuration::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Configuration (*this, f, c);
  }

  Configuration& Configuration::
  operator= (const Configuration& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->content_order_ = x.content_order_;
      this->StandardMetaData_ = x.StandardMetaData_;
      this->CalculatedVariableGenericFormula_ = x.CalculatedVariableGenericFormula_;
      this->Regs_ = x.Regs_;
      this->CalculatedVariable_ = x.CalculatedVariable_;
      this->FreeVariable_ = x.FreeVariable_;
    }

    return *this;
  }

  Configuration::
  ~Configuration ()
  {
  }

  // type
  //

  type::
  type (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_type_convert ();
  }

  type::
  type (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_type_convert ();
  }

  type::
  type (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_type_convert ();
  }

  type* type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type (*this, f, c);
  }

  type::value type::
  _xsd_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_type_indexes_,
                      _xsd_type_indexes_ + 12,
                      *this,
                      c));

    if (i == _xsd_type_indexes_ + 12 || _xsd_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const type::
  _xsd_type_literals_[12] =
  {
    "Boolean",
    "Byte",
    "SByte",
    "UInt16",
    "Int16",
    "UInt32",
    "Int32",
    "UInt64",
    "Int64",
    "Double",
    "Float",
    "String"
  };

  const type::value type::
  _xsd_type_indexes_[12] =
  {
    ::Configuration::type::Boolean,
    ::Configuration::type::Byte,
    ::Configuration::type::Double,
    ::Configuration::type::Float,
    ::Configuration::type::Int16,
    ::Configuration::type::Int32,
    ::Configuration::type::Int64,
    ::Configuration::type::SByte,
    ::Configuration::type::String,
    ::Configuration::type::UInt16,
    ::Configuration::type::UInt32,
    ::Configuration::type::UInt64
  };
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace Configuration
{
  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::Configuration::Configuration > (
      ::Configuration::configuration (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Configuration::Configuration > (
      ::Configuration::configuration (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Configuration::Configuration > (
      ::Configuration::configuration (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Configuration::configuration (isrc, f, p);
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Configuration::configuration (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::Configuration::configuration (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Configuration::configuration (isrc, f, p);
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Configuration::configuration (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::Configuration::configuration (isrc, h, f, p);
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::Configuration::Configuration > (
      ::Configuration::configuration (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Configuration::Configuration > (
      ::Configuration::configuration (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::Configuration::Configuration > (
      ::Configuration::configuration (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::Configuration::Configuration > (
        ::Configuration::configuration (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "configuration" &&
        n.namespace_ () == "http://cern.ch/quasar/Configuration")
    {
      ::std::unique_ptr< ::Configuration::Configuration > r (
        ::xsd::cxx::tree::traits< ::Configuration::Configuration, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "configuration",
      "http://cern.ch/quasar/Configuration");
  }

  ::std::unique_ptr< ::Configuration::Configuration >
  configuration (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "configuration" &&
        n.namespace_ () == "http://cern.ch/quasar/Configuration")
    {
      ::std::unique_ptr< ::Configuration::Configuration > r (
        ::xsd::cxx::tree::traits< ::Configuration::Configuration, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "configuration",
      "http://cern.ch/quasar/Configuration");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace Configuration
{
  void
  operator<< (::xercesc::DOMElement& e, const StandardMetaData& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    for (StandardMetaData::content_order_const_iterator
         b (i.content_order ().begin ()), n (i.content_order ().end ());
         b != n; ++b)
    {
      switch (b->id)
      {
        // Quasar
        //
        case StandardMetaData::Quasar_id:
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Quasar",
              "http://cern.ch/quasar/Configuration",
              e));

          s << *i.Quasar ();
          continue;
        }
        // Log
        //
        case StandardMetaData::Log_id:
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Log",
              "http://cern.ch/quasar/Configuration",
              e));

          s << *i.Log ();
          continue;
        }
        // SourceVariableThreadPool
        //
        case StandardMetaData::SourceVariableThreadPool_id:
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "SourceVariableThreadPool",
              "http://cern.ch/quasar/Configuration",
              e));

          s << *i.SourceVariableThreadPool ();
          continue;
        }
        // Server
        //
        case StandardMetaData::Server_id:
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Server",
              "http://cern.ch/quasar/Configuration",
              e));

          s << *i.Server ();
          continue;
        }
        default:
        {
          break;
        }
      }

      break;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Log& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    for (Log::content_order_const_iterator
         b (i.content_order ().begin ()), n (i.content_order ().end ());
         b != n; ++b)
    {
      switch (b->id)
      {
        // GeneralLogLevel
        //
        case Log::GeneralLogLevel_id:
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "GeneralLogLevel",
              "http://cern.ch/quasar/Configuration",
              e));

          s << *i.GeneralLogLevel ();
          continue;
        }
        // ComponentLogLevels
        //
        case Log::ComponentLogLevels_id:
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ComponentLogLevels",
              "http://cern.ch/quasar/Configuration",
              e));

          s << *i.ComponentLogLevels ();
          continue;
        }
        default:
        {
          break;
        }
      }

      break;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GeneralLogLevel& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // logLevel
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "logLevel",
          e));

      a << i.logLevel ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ComponentLogLevels& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    for (ComponentLogLevels::content_order_const_iterator
         b (i.content_order ().begin ()), n (i.content_order ().end ());
         b != n; ++b)
    {
      switch (b->id)
      {
        // ComponentLogLevel
        //
        case ComponentLogLevels::ComponentLogLevel_id:
        {
          const ComponentLogLevels::ComponentLogLevel_type& x (i.ComponentLogLevel ()[b->index]);

          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ComponentLogLevel",
              "http://cern.ch/quasar/Configuration",
              e));

          s << x;
          continue;
        }
        default:
        {
          break;
        }
      }

      break;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ComponentLogLevel& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // componentName
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "componentName",
          e));

      a << i.componentName ();
    }

    // logLevel
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "logLevel",
          e));

      a << i.logLevel ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SourceVariableThreadPool& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // minThreads
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "minThreads",
          e));

      a << i.minThreads ();
    }

    // maxThreads
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxThreads",
          e));

      a << i.maxThreads ();
    }

    // maxJobs
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxJobs",
          e));

      a << i.maxJobs ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const logLevelIdentifier& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const logLevelIdentifier& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const logLevelIdentifier& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Quasar& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const Quasar&)
  {
  }

  void
  operator<< (::xml_schema::list_stream&,
              const Quasar&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const Server& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const Server&)
  {
  }

  void
  operator<< (::xml_schema::list_stream&,
              const Server&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const ObjectName& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ObjectName& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const ObjectName& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const CalculatedVariable& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.value ();
    }

    // initialValue
    //
    if (i.initialValue ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "initialValue",
          e));

      a << ::xml_schema::as_double(*i.initialValue ());
    }

    // isBoolean
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isBoolean",
          e));

      a << i.isBoolean ();
    }

    // status
    //
    if (i.status ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "status",
          e));

      a << *i.status ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CalculatedVariableGenericFormula& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // formula
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "formula",
          e));

      a << i.formula ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const FreeVariable& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type ();
    }

    // initialValue
    //
    if (i.initialValue ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "initialValue",
          e));

      a << *i.initialValue ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Regs& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    for (Regs::content_order_const_iterator
         b (i.content_order ().begin ()), n (i.content_order ().end ());
         b != n; ++b)
    {
      switch (b->id)
      {
        // CalculatedVariable
        //
        case Regs::CalculatedVariable_id:
        {
          const Regs::CalculatedVariable_type& x (i.CalculatedVariable ()[b->index]);

          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CalculatedVariable",
              "http://cern.ch/quasar/Configuration",
              e));

          s << x;
          continue;
        }
        // FreeVariable
        //
        case Regs::FreeVariable_id:
        {
          const Regs::FreeVariable_type& x (i.FreeVariable ()[b->index]);

          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "FreeVariable",
              "http://cern.ch/quasar/Configuration",
              e));

          s << x;
          continue;
        }
        default:
        {
          break;
        }
      }

      break;
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // address
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "address",
          e));

      a << i.address ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Configuration& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    for (Configuration::content_order_const_iterator
         b (i.content_order ().begin ()), n (i.content_order ().end ());
         b != n; ++b)
    {
      switch (b->id)
      {
        // StandardMetaData
        //
        case Configuration::StandardMetaData_id:
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "StandardMetaData",
              "http://cern.ch/quasar/Configuration",
              e));

          s << *i.StandardMetaData ();
          continue;
        }
        // CalculatedVariableGenericFormula
        //
        case Configuration::CalculatedVariableGenericFormula_id:
        {
          const Configuration::CalculatedVariableGenericFormula_type& x (i.CalculatedVariableGenericFormula ()[b->index]);

          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CalculatedVariableGenericFormula",
              "http://cern.ch/quasar/Configuration",
              e));

          s << x;
          continue;
        }
        // Regs
        //
        case Configuration::Regs_id:
        {
          const Configuration::Regs_type& x (i.Regs ()[b->index]);

          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Regs",
              "http://cern.ch/quasar/Configuration",
              e));

          s << x;
          continue;
        }
        // CalculatedVariable
        //
        case Configuration::CalculatedVariable_id:
        {
          const Configuration::CalculatedVariable_type& x (i.CalculatedVariable ()[b->index]);

          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CalculatedVariable",
              "http://cern.ch/quasar/Configuration",
              e));

          s << x;
          continue;
        }
        // FreeVariable
        //
        case Configuration::FreeVariable_id:
        {
          const Configuration::FreeVariable_type& x (i.FreeVariable ()[b->index]);

          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "FreeVariable",
              "http://cern.ch/quasar/Configuration",
              e));

          s << x;
          continue;
        }
        default:
        {
          break;
        }
      }

      break;
    }
  }

  void
  configuration (::std::ostream& o,
                 const ::Configuration::Configuration& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::Configuration::configuration (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  configuration (::std::ostream& o,
                 const ::Configuration::Configuration& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::Configuration::configuration (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  configuration (::std::ostream& o,
                 const ::Configuration::Configuration& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::Configuration::configuration (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  configuration (::xercesc::XMLFormatTarget& t,
                 const ::Configuration::Configuration& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::Configuration::configuration (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  configuration (::xercesc::XMLFormatTarget& t,
                 const ::Configuration::Configuration& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::Configuration::configuration (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  configuration (::xercesc::XMLFormatTarget& t,
                 const ::Configuration::Configuration& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::Configuration::configuration (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  configuration (::xercesc::DOMDocument& d,
                 const ::Configuration::Configuration& s,
                 ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "configuration" &&
        n.namespace_ () == "http://cern.ch/quasar/Configuration")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "configuration",
        "http://cern.ch/quasar/Configuration");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  configuration (const ::Configuration::Configuration& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "configuration",
        "http://cern.ch/quasar/Configuration",
        m, f));

    ::Configuration::configuration (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const type& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const type& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const type& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

