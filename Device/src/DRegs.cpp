/*  �� Copyright CERN, 2015. All rights not expressly granted are reserved.

    The stub of this file was generated by quasar (https://github.com/quasar-team/quasar/)

    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.


 */


#include <Configuration.hxx> // TODO; should go away, is already in Base class for ages

#include <DRegs.h>
#include <ASRegs.h>
#include <string>

// ECC - include files for reading from /dev/mem (and maybe some extraneous things)
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>
#include <ctype.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <iostream>
#include <iomanip>

// ECC stuff for i2c
#include "malloc.h"
#include "xtypes.h"
#include "i2cBus.h"
#include "i2cDevUser.h"   /* Here "Dev" means /dev/i2c-X calls to access the bus. */
#include "tmp100.h"
#include "ltc2945.h"
#include "pca8575.h"
#include "firefly.h"
#include "ddr4.h"
#include "zynqOnBoard.h"

#include "sensorI2C.h"
#include "sensorData.h"
#include "sensorSRTM.h"
#include "sensorInitSRTM_hw2.h"

#include "SysInfo.h"
#include "cJSON.h"
#include "json_provider.h"




namespace Device
{
// 1111111111111111111111111111111111111111111111111111111111111111111111111
// 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
// 1     Users don't modify this code!!!!                                  1
// 1     If you modify this code you may start a fire or a flood somewhere,1
// 1     and some human being may possible cease to exist. You don't want  1
// 1     to be charged with that!                                          1
// 1111111111111111111111111111111111111111111111111111111111111111111111111


//static off_t bram_pbase;
static OpcUa_UInt32 saved_setval;


// 2222222222222222222222222222222222222222222222222222222222222222222222222
// 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
// 2     (code for which only stubs were generated automatically)          2
// 2     You should add the implementation but dont alter the headers      2
// 2     (apart from constructor, in which you should complete initializati2
// 2     on list)                                                          2
// 2222222222222222222222222222222222222222222222222222222222222222222222222

/* sample ctr */
DRegs::DRegs (
    const Configuration::Regs& config,
    Parent_DRegs* parent
):
    Base_DRegs( config, parent)

    /* fill up constructor initialization list here */
{
    /* fill up constructor body here */

	// initialize the base address from the configuration file
	LOG(Log::INF) << "Register address: " << std::hex << config.address();

}

/* sample dtr */

DRegs::~DRegs ()
{
}


/* delegates for cachevariables */

// update output from /dev/mem
void DRegs::update() {

  static int maxprint = 0;
  static int first = 1;

  // ECC - Read from /dev/mem
  unsigned int bram_size = 0x8000;

  // This is the physical base address which is set by the constructor
  off_t bram_pbase = address();
  OpcUa_UInt32 *bram32_vptr;

  // see if we want to write to this address
  OpcUa_UInt32 setval = 0;
  getAddressSpaceLink()->getWriteRegValue(setval);

  // initialize write value here since I can't figure out how to do this in the constructor
  if (first) {
    saved_setval = setval;
    LOG(Log::INF) << "Register setval: " << std::hex << saved_setval;
    first = 0;

    // ECC - only do the sensor stuff for now
    sensorInitSRTM_hw2();
    LOG(Log::INF) << "Initialized sensor stuff.";
  }


  /* Get i2c data */
  sensorMonitor(0);

  // format sensor data. 
  // This is necessary to fill the appropriate arrays even though we don't access the cJSON data
  cJSON *top = cJSON_CreateObject();
  sysinfoFormat(top);
  sensorFormat(top);

  // ECC - open file for output --- This is temporary to check that it works
  FILE *json_file = fopen("SRTM-sensor.output.txt","w");
  char *string_json = NULL;
  string_json = cJSON_Print(top);
  fprintf(json_file, string_json);
  fclose(json_file);

  int tot_sensors = sensorCount();


  // print out the sensor data
  if (maxprint < 3) {
    std::cout << "Number of sensors: " << tot_sensors << std::endl;
    for (int i=0; i<tot_sensors; i++) {
      const struct sensorRecord *sensor_data;
      sensor_data = sensorGet(i);
      std::cout << "i: " << i << " name: " << sensor_data->name;
      void *buffer = sensor_data->valueBuffer;
      if (i<8) {
	float val1 = *static_cast<float *>(buffer);
	std::cout << " val1: " << val1 << std::endl;
      }
      else std::cout << std::endl;
    }
  }


  // For now just do the first 8 sensors...
  const struct sensorRecord *sdata;
  float value;
  sdata = sensorGet(0);
  value = *static_cast<float *>(sdata->valueBuffer);
  getAddressSpaceLink()->setSRTM_v00(value,OpcUa_Good);
  sdata = sensorGet(1);
  value = *static_cast<float *>(sdata->valueBuffer);
  getAddressSpaceLink()->setSRTM_v01(value,OpcUa_Good);
  sdata = sensorGet(2);
  value = *static_cast<float *>(sdata->valueBuffer);
  getAddressSpaceLink()->setSRTM_v02(value,OpcUa_Good);
  sdata = sensorGet(3);
  value = *static_cast<float *>(sdata->valueBuffer);
  getAddressSpaceLink()->setSRTM_v03(value,OpcUa_Good);
  sdata = sensorGet(4);
  value = *static_cast<float *>(sdata->valueBuffer);
  getAddressSpaceLink()->setSRTM_v04(value,OpcUa_Good);
  sdata = sensorGet(5);
  value = *static_cast<float *>(sdata->valueBuffer);
  getAddressSpaceLink()->setSRTM_v05(value,OpcUa_Good);
  sdata = sensorGet(6);
  value = *static_cast<float *>(sdata->valueBuffer);
  getAddressSpaceLink()->setSRTM_v06(value,OpcUa_Good);
  sdata = sensorGet(7);
  value = *static_cast<float *>(sdata->valueBuffer);
  getAddressSpaceLink()->setSRTM_v07(value,OpcUa_Good);

  // Get firefly data
  cJSON *sensor_json = NULL;
  cJSON *ff_json = NULL;
  cJSON *uptime_json = NULL;
  cJSON *tempC_json = NULL;
  cJSON *rxpower_json = NULL;
  cJSON *rxpower0_json, *rxpower1_json, *rxpower2_json, *rxpower3_json;
  double tempC = -99;
  double uptime = -99;
  double rxpower_0, rxpower_1, rxpower_2, rxpower_3;

  sensor_json = cJSON_GetObjectItem(top, "sensor");
  if (sensor_json) ff_json = cJSON_GetObjectItem(sensor_json, "firefly13");
  if (ff_json) uptime_json = cJSON_GetObjectItem(ff_json, "uptime");
  if (ff_json) tempC_json = cJSON_GetObjectItem(ff_json, "tempC");
  if (ff_json) rxpower_json = cJSON_GetObjectItem(ff_json, "rxpower");
  if (uptime_json) uptime = uptime_json->valuedouble;
  if (tempC_json) tempC = tempC_json->valuedouble;
  if (rxpower_json) rxpower0_json = cJSON_GetArrayItem(rxpower_json,0);
  if (rxpower_json) rxpower1_json = cJSON_GetArrayItem(rxpower_json,1);
  if (rxpower_json) rxpower2_json = cJSON_GetArrayItem(rxpower_json,2);
  if (rxpower_json) rxpower3_json = cJSON_GetArrayItem(rxpower_json,3);
  if (rxpower0_json) rxpower_0 = rxpower0_json->valuedouble;
  if (rxpower1_json) rxpower_1 = rxpower1_json->valuedouble;
  if (rxpower2_json) rxpower_2 = rxpower2_json->valuedouble;
  if (rxpower3_json) rxpower_3 = rxpower3_json->valuedouble;

  if (maxprint<3) {
    std::cout << "filefly13 uptime: " << uptime << std::endl;
    std::cout << "firefly13 tempC: " << tempC << std::endl;
    std::cout << "firefly13 rxpower_0: " << rxpower_0 << std::endl;
    std::cout << "firefly13 rxpower_1: " << rxpower_1 << std::endl;
    std::cout << "firefly13 rxpower_2: " << rxpower_2 << std::endl;
    std::cout << "firefly13 rxpower_3: " << rxpower_3 << std::endl;
  }

  maxprint++;

  getAddressSpaceLink()->setFF13_uptime(uptime,OpcUa_Good);
  getAddressSpaceLink()->setFF13_tempC(tempC,OpcUa_Good);
  getAddressSpaceLink()->setFF13_rxpower_0(rxpower_0,OpcUa_Good);
  getAddressSpaceLink()->setFF13_rxpower_1(rxpower_1,OpcUa_Good);
  getAddressSpaceLink()->setFF13_rxpower_2(rxpower_2,OpcUa_Good);
  getAddressSpaceLink()->setFF13_rxpower_3(rxpower_3,OpcUa_Good);

  // Get FPGA values
  cJSON *FPGA_json;
  cJSON *FPGA_up_json;
  double FPGA_up = -99;
  if (sensor_json) FPGA_json = cJSON_GetObjectItem(sensor_json, "fpga");
  if (FPGA_json) FPGA_up_json = cJSON_GetObjectItem(FPGA_json, "up");
  if (FPGA_up_json) FPGA_up = FPGA_up_json->valuedouble;
  getAddressSpaceLink()->setFPGA_up(FPGA_up,OpcUa_Good);

  // ECC - be sure to delete cJSON object
  cJSON_Delete(top);

 /******
  // Push the values to the OpcUa client display
  // See Sensor/src/firefly.c for definitions
  // And see Design/Design.xml for names of address space links
  getAddressSpaceLink()->setUserReg(val,OpcUa_Good);


  // Compare values of FF11 txdisable and set value. Enable/disable if different.
  OpcUa_UInt32 setval_tx = 0;
  getAddressSpaceLink()->getFF11txwrite(setval_tx);
  OpcUa_UInt32 FF11_txdisable = ff_vals[3];
  if (FF11_txdisable != setval_tx) {
      
   // Loop over the four channels
    for (int ichan=0; ichan<nFFchan; ichan++) {
      int ibitset = (setval_tx >> ichan) & 1;
      int ibitval = (FF11_txdisable >> ichan) & 1;

      // only change enable if the two bits differ
      if (ibitset != ibitval) {
	if (ibitset == 0) fcChanEnable(16, ichan);
	else              fcChanDisable(16, ichan);
      }
    }
  }
  
  // Compare values of FF12 txdisable and set value. Enable/disable if different.
  getAddressSpaceLink()->getFF12txwrite(setval_tx);
  OpcUa_UInt32 FF12_txdisable = ff_vals[3+FF12off];
  if (FF12_txdisable != setval_tx) {
      
   // Loop over the four channels
    for (int ichan=0; ichan<nFFchan; ichan++) {
      int ibitset = (setval_tx >> ichan) & 1;
      int ibitval = (FF12_txdisable >> ichan) & 1;

      // only change enable if the two bits differ
      if (ibitset != ibitval) {
	if (ibitset == 0) fcChanEnable(15, ichan);
	else              fcChanDisable(15, ichan);
      }
    }
  }
  ************/


}

/* delegators for methods */

// 3333333333333333333333333333333333333333333333333333333333333333333333333
// 3     FULLY CUSTOM CODE STARTS HERE                                     3
// 3     Below you put bodies for custom methods defined for this class.   3
// 3     You can do whatever you want, but please be decent.               3
// 3333333333333333333333333333333333333333333333333333333333333333333333333

}


